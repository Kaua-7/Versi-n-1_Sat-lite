// =====================================================
// üõ∞Ô∏è SAT√âLITE v4.6 - Compatible GUI base
// DHT + Ultrasonidos + Servo + √ìrbita + Checksum
// =====================================================

#include <SoftwareSerial.h>
#include <DHT.h>
#include <Servo.h>

// ------------------ PINES ------------------
#define DHTPIN 2
#define DHTTYPE DHT11
#define TRIGPIN 6
#define ECHOPIN 7
#define SERVOPIN 9
#define MOTORPIN 12
#define LEDRX 13

// ------------------ OBJETOS ------------------
SoftwareSerial mySerial(10, 11); // RX, TX hacia estaci√≥n (puente)
DHT dht(DHTPIN, DHTTYPE);
Servo servoMotor;

// ------------------ ESTADO GLOBAL ------------------
bool transmitiendo = false;
bool modoBarrido   = false;   // true = barrido autom√°tico, false = manual
bool arduinoComputeAvg = false;

// ------------------ TIEMPOS ------------------
unsigned long intervaloHT    = 5000;
unsigned long nextHT         = 0;

unsigned long intervaloServo = 300;   // servo cada 0.3 s en barrido
unsigned long nextServo      = 0;

unsigned long intervaloUltra = 300;   // mismo ritmo que el servo
unsigned long intervaloOrbit = 3000;
unsigned long nextOrbit      = 0;

// ------------------ SERVO ------------------
int angulo     = 90;   // posici√≥n inicial
int direccion  = 1;
const int PASO = 15;

// ------------------ MEDIA TEMPERATURA ------------------
#define MAX_WINDOW 100
float tempBuffer[MAX_WINDOW];
int   tempCount = 0;
int   windowN   = 10;

// ------------------ √ìRBITA ------------------
const double G                = 6.67430e-11;
const double M                = 5.97219e24;
const double R_EARTH          = 6371000;
const double ALTITUDE         = 400000;
const double TIME_COMPRESSION = 90.0;

double r;
double real_orbital_period;

// =====================================================
// CHECKSUM
// =====================================================
unsigned int checksum(String msg) {
  unsigned int sum = 0;
  for (unsigned int i = 0; i < msg.length(); i++) sum += msg[i];
  return sum % 256;
}

void sendMsg(String msg) {
  mySerial.print("CHK:");
  mySerial.print(msg);
  mySerial.print(":");
  mySerial.println(checksum(msg));
}

// =====================================================
// LIMPIAR CHECKSUM ENTRANTE
// =====================================================
String limpiarChecksum(String raw) {
  raw.trim();
  if (!raw.startsWith("CHK:")) return raw;
  raw = raw.substring(4);               // quitar "CHK:"
  int lastColon = raw.lastIndexOf(':'); // quitar checksum final
  if (lastColon > 0) raw = raw.substring(0, lastColon);
  return raw;
}

// =====================================================
// DISTANCIA ULTRASONIDOS (cm)
// =====================================================
float medirDistancia() {
  digitalWrite(TRIGPIN, LOW); delayMicroseconds(2);
  digitalWrite(TRIGPIN, HIGH); delayMicroseconds(10);
  digitalWrite(TRIGPIN, LOW);

  long duracion = pulseIn(ECHOPIN, HIGH, 25000);
  if (duracion == 0) return -1;
  return duracion * 0.034 / 2.0;
}

// =====================================================
// MEDIA TEMPERATURA
// =====================================================
void pushTemp(float t) {
  if (tempCount < MAX_WINDOW) tempBuffer[tempCount++] = t;
  else {
    for (int i = 0; i < MAX_WINDOW - 1; i++)
      tempBuffer[i] = tempBuffer[i + 1];
    tempBuffer[MAX_WINDOW - 1] = t;
  }
}

float computeAvg() {
  int n = min(tempCount, windowN);
  if (n == 0) return NAN;
  float s = 0;
  for (int i = tempCount - n; i < tempCount; i++) s += tempBuffer[i];
  return s / n;
}

// =====================================================
// √ìRBITA (formato texto compatible con regex_orbit de tu GUI)
// =====================================================
void enviarOrbita(unsigned long ms) {
  double time  = (ms / 1000.0) * TIME_COMPRESSION;
  double angle = 2 * PI * (time / real_orbital_period);

  double x = r * cos(angle);
  double y = r * sin(angle);
  double z = 0;

  String msg = "Orbit | Time: " + String(time, 2) +
               " s | X: "  + String(x, 2) +
               " m, Y: "   + String(y, 2) +
               " m, Z: "   + String(z, 2);

  sendMsg(msg);
}

// =====================================================
// PROCESAR COMANDOS
// =====================================================
void procesarComando(String cmd) {
  cmd.trim();
  if (cmd.length() == 0) return;

  // ---------- COMANDOS TEXTO ----------
  if (cmd == "Iniciar") {
    transmitiendo = true;
    modoBarrido  = true;                 // ‚Üê activar barrido al iniciar
    nextHT = nextServo = nextOrbit = millis();
    sendMsg("5:INICIADO");
    return;
  }

  if (cmd == "Parar") {
    transmitiendo = false;
    // NO tocamos modoBarrido: se mantiene el estado
    sendMsg("5:PARADO");
    return;
  }

  // ---------- COMANDOS NUM√âRICOS ----------
  int sep  = cmd.indexOf(':');
  int code = (sep < 0) ? cmd.toInt() : cmd.substring(0, sep).toInt();
  String val = (sep < 0) ? "" : cmd.substring(sep + 1);

  switch (code) {

    case 1: { // intervalo DHT
      int s = val.toInt();
      if (s >= 1 && s <= 3600) {
        intervaloHT = s * 1000UL;
        nextHT = millis() + intervaloHT;
        sendMsg("5:PERIODO_DHT=" + String(s));
      }
      break;
    }

    case 2: { // SERVO MANUAL
      angulo = constrain(val.toInt(), 0, 180);
      modoBarrido = false;        // pasa a modo manual
      servoMotor.write(angulo);   // mueve de inmediato
      sendMsg("5:SERVO_MANUAL=" + String(angulo));
      break;
    }

    case 6: { // BARRIDO ON/OFF
      modoBarrido = (val == "1");
      sendMsg(modoBarrido ? "5:BARRIDO_ON" : "5:BARRIDO_OFF");
      break;
    }

    case 7: { // intervalo ultrasonidos (no se usa a√∫n en l√≥gica)
      intervaloUltra = constrain(val.toInt(), 100, 10000);
      sendMsg("5:ULTRA_MS=" + String(intervaloUltra));
      break;
    }

    case 8: { // media en Arduino
      arduinoComputeAvg = (val == "1");
      sendMsg(arduinoComputeAvg ? "5:AVG_ON" : "5:AVG_OFF");
      break;
    }

    case 9: { // ventana media
      windowN = constrain(val.toInt(), 1, MAX_WINDOW);
      sendMsg("5:WINDOW=" + String(windowN));
      break;
    }

    default:
      sendMsg("5:CMD_DESCONOCIDO");
  }
}

// =====================================================
// SETUP
// =====================================================
void setup() {
  pinMode(TRIGPIN, OUTPUT);
  pinMode(ECHOPIN, INPUT);
  pinMode(MOTORPIN, OUTPUT);
  pinMode(LEDRX, OUTPUT);

  servoMotor.attach(SERVOPIN);
  servoMotor.write(angulo);

  dht.begin();
  Serial.begin(9600);   // depuraci√≥n local
  mySerial.begin(9600); // hacia puente

  r = R_EARTH + ALTITUDE;
  real_orbital_period = 2 * PI * sqrt(pow(r, 3) / (G * M));

  sendMsg("5:SATELITE_LISTO");
}

// =====================================================
// LOOP
// =====================================================
void loop() {
  // 1Ô∏è‚É£ COMANDOS
  while (mySerial.available()) {
    String raw   = mySerial.readStringUntil('\n');
    String limpio = limpiarChecksum(raw);
    procesarComando(limpio);
  }

  // Aunque no se transmita, en manual mantenemos el √°ngulo
  if (!transmitiendo) {
    if (!modoBarrido) {
      servoMotor.write(angulo);
    }
    return;
  }

  // 2Ô∏è‚É£ DHT
  if (millis() >= nextHT) {
    nextHT = millis() + intervaloHT;

    float t = dht.readTemperature();
    float h = dht.readHumidity();

    if (!isnan(t) && !isnan(h)) pushTemp(t);
    String msg = "1:" + String(t, 2) + ":" + String(h, 2);
    if (arduinoComputeAvg) msg += ":A:" + String(computeAvg(), 2);
    sendMsg(msg);
  }

  // 3Ô∏è‚É£ SERVO + RADAR
  if (modoBarrido) {
    if (millis() >= nextServo) {
      nextServo = millis() + intervaloServo;

      angulo += PASO * direccion;
      if (angulo >= 180 || angulo <= 0) direccion *= -1;
      servoMotor.write(angulo);

      float d = medirDistancia();
      if (d < 0) {
        sendMsg("6:");
        Serial.println("DBG RADAR_FALLO");
      } else {
        String s = "2:" + String(angulo) + ":" + String(d, 2);
        sendMsg(s);
        Serial.print("DBG RADAR_OK "); Serial.println(s);
      }
    }
  } else {
    servoMotor.write(angulo);
  }

  // 4Ô∏è‚É£ √ìRBITA
  if (millis() >= nextOrbit) {
    nextOrbit = millis() + intervaloOrbit;
    enviarOrbita(millis());
  }
}

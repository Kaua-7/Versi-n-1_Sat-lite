// =====================================================
// üõ∞Ô∏è SAT√âLITE v4.4 FINAL
// DHT + Ultrasonidos + Servo + √ìrbita + Checksum + LoRa
// =====================================================

#include <SoftwareSerial.h>
#include <DHT.h>
#include <Servo.h>

// ------------------ PINES ------------------
#define DHTPIN 2
#define DHTTYPE DHT11
#define TRIGPIN 6
#define ECHOPIN 7
#define SERVOPIN 9
#define MOTORPIN 12
#define LEDRX 13

// ------------------ OBJETOS ------------------
SoftwareSerial mySerial(10, 11); // RX, TX hacia estaci√≥n
DHT dht(DHTPIN, DHTTYPE);
Servo servoMotor;

// ------------------ ESTADO GLOBAL ------------------
bool transmitiendo = false;
bool modoBarrido = false;
bool arduinoComputeAvg = false;

// ------------------ TIEMPOS ------------------
unsigned long intervaloHT = 5000;
unsigned long nextHT = 0;

unsigned long intervaloServo = 1000;   // servo cada 1 s
unsigned long nextServo = 0;

unsigned long intervaloUltra = 1000;   // radar ligado al servo

unsigned long intervaloOrbit = 3000;
unsigned long nextOrbit = 0;

// ------------------ SERVO ------------------
int angulo = 0;
int direccion = 1;
const int PASO = 30;

// ------------------ MEDIA TEMPERATURA ------------------
#define MAX_WINDOW 100
float tempBuffer[MAX_WINDOW];
int tempCount = 0;
int windowN = 10;

// ------------------ √ìRBITA ------------------
const double G = 6.67430e-11;
const double M = 5.97219e24;
const double R_EARTH = 6371000;
const double ALTITUDE = 400000;
const double TIME_COMPRESSION = 90.0;

double r;
double real_orbital_period;

// =====================================================
// CHECKSUM
// =====================================================
unsigned int checksum(String msg) {
  unsigned int sum = 0;
  for (unsigned int i = 0; i < msg.length(); i++) sum += msg[i];
  return sum % 256;
}

void sendMsg(String msg) {
  mySerial.print("CHK:");
  mySerial.print(msg);
  mySerial.print(":");
  mySerial.println(checksum(msg));
}

// =====================================================
// LIMPIAR CHECKSUM ENTRANTE (CLAVE)
// =====================================================
String limpiarChecksum(String raw) {
  raw.trim();
  if (!raw.startsWith("CHK:")) return raw;

  raw = raw.substring(4);               // quitar "CHK:"
  int lastColon = raw.lastIndexOf(':');  // quitar checksum
  if (lastColon > 0) raw = raw.substring(0, lastColon);
  return raw;
}

// =====================================================
// DISTANCIA ULTRASONIDOS (cm)
// =====================================================
float medirDistancia() {
  digitalWrite(TRIGPIN, LOW); delayMicroseconds(2);
  digitalWrite(TRIGPIN, HIGH); delayMicroseconds(10);
  digitalWrite(TRIGPIN, LOW);

  long duracion = pulseIn(ECHOPIN, HIGH, 25000);
  if (duracion == 0) return -1;
  return duracion * 0.034 / 2.0;
}

// =====================================================
// MEDIA TEMPERATURA
// =====================================================
void pushTemp(float t) {
  if (tempCount < MAX_WINDOW) tempBuffer[tempCount++] = t;
  else {
    for (int i = 0; i < MAX_WINDOW - 1; i++)
      tempBuffer[i] = tempBuffer[i + 1];
    tempBuffer[MAX_WINDOW - 1] = t;
  }
}

float computeAvg() {
  int n = min(tempCount, windowN);
  if (n == 0) return NAN;
  float s = 0;
  for (int i = tempCount - n; i < tempCount; i++) s += tempBuffer[i];
  return s / n;
}

// =====================================================
// √ìRBITA
// =====================================================
void enviarOrbita(unsigned long ms) {
  double time = (ms / 1000.0) * TIME_COMPRESSION;
  double angle = 2 * PI * (time / real_orbital_period);

  double x = r * cos(angle);
  double y = r * sin(angle);
  double z = 0;

  String msg = "4:" + String(time, 2) + ":" +
               String(x, 2) + ":" +
               String(y, 2) + ":" +
               String(z, 2);

  sendMsg(msg);
}

// =====================================================
// PROCESAR COMANDOS
// =====================================================
void procesarComando(String cmd) {
  cmd.trim();
  if (cmd.length() == 0) return;

  // ---------- COMANDOS TEXTO ----------
  if (cmd == "Iniciar") {
    transmitiendo = true;
    modoBarrido = true;
    nextHT = nextServo = nextOrbit = millis();
    sendMsg("5:INICIADO");
    return;
  }

  if (cmd == "Parar") {
    transmitiendo = false;
    modoBarrido = false;
    sendMsg("5:PARADO");
    return;
  }

  // ---------- COMANDOS NUM√âRICOS ----------
  int sep = cmd.indexOf(':');
  int code = (sep < 0) ? cmd.toInt() : cmd.substring(0, sep).toInt();
  String val = (sep < 0) ? "" : cmd.substring(sep + 1);

  switch (code) {

    case 1: { // intervalo DHT
      int s = val.toInt();
      if (s >= 1 && s <= 3600) {
        intervaloHT = s * 1000UL;
        nextHT = millis() + intervaloHT;
        sendMsg("5:PERIODO_DHT=" + String(s));
      }
      break;
    }

    case 2: { // servo manual
      angulo = constrain(val.toInt(), 0, 180);
      servoMotor.write(angulo);
      modoBarrido = false;
      sendMsg("5:SERVO=" + String(angulo));
      break;
    }

    case 3: { // detener transmisi√≥n
      transmitiendo = false;
      sendMsg("5:TX_OFF");
      break;
    }

    case 4: { // reanudar transmisi√≥n
      transmitiendo = true;
      nextHT = nextServo = nextOrbit = millis();
      sendMsg("5:TX_ON");
      break;
    }

    case 6: { // barrido on/off
      modoBarrido = (val == "1");
      sendMsg(modoBarrido ? "5:BARRIDO_ON" : "5:BARRIDO_OFF");
      break;
    }

    case 7: { // intervalo ultrasonidos
      intervaloUltra = constrain(val.toInt(), 100, 10000);
      sendMsg("5:ULTRA_MS=" + String(intervaloUltra));
      break;
    }

    case 8: { // media en Arduino
      arduinoComputeAvg = (val == "1");
      sendMsg(arduinoComputeAvg ? "5:AVG_ON" : "5:AVG_OFF");
      break;
    }

    case 9: { // ventana media
      windowN = constrain(val.toInt(), 1, MAX_WINDOW);
      sendMsg("5:WINDOW=" + String(windowN));
      break;
    }

    default:
      sendMsg("5:CMD_DESCONOCIDO");
  }
}

// =====================================================
// SETUP
// =====================================================
void setup() {
  pinMode(TRIGPIN, OUTPUT);
  pinMode(ECHOPIN, INPUT);
  pinMode(MOTORPIN, OUTPUT);
  pinMode(LEDRX, OUTPUT);

  servoMotor.attach(SERVOPIN);
  servoMotor.write(angulo);

  dht.begin();
  Serial.begin(9600);
  mySerial.begin(9600);

  r = R_EARTH + ALTITUDE;
  real_orbital_period = 2 * PI * sqrt(pow(r, 3) / (G * M));

  sendMsg("5:SATELITE_LISTO");
}

// =====================================================
// LOOP
// =====================================================
void loop() {

  // 1Ô∏è‚É£ COMANDOS (SIEMPRE ACTIVOS)
  while (mySerial.available()) {
    String raw = mySerial.readStringUntil('\n');
    String limpio = limpiarChecksum(raw);
    procesarComando(limpio);
  }

  if (!transmitiendo) return;

  // 2Ô∏è‚É£ DHT
  if (millis() >= nextHT) {
    nextHT = millis() + intervaloHT;

    float t = dht.readTemperature();
    float h = dht.readHumidity();

    if (isnan(t) || isnan(h)) {
      sendMsg("3:");
    } else {
      pushTemp(t);
      String msg = "1:" + String(t, 2) + ":" + String(h, 2);
      if (arduinoComputeAvg)
        msg += ":A:" + String(computeAvg(), 2);
      sendMsg(msg);
    }
  }

  // 3Ô∏è‚É£ SERVO + RADAR (SINCRONIZADOS)
  if (modoBarrido && millis() >= nextServo) {
    nextServo = millis() + intervaloServo;

    angulo += PASO * direccion;
    if (angulo >= 180 || angulo <= 0) direccion *= -1;
    servoMotor.write(angulo);

    float d = medirDistancia();
    if (d < 0) sendMsg("6:");
    else sendMsg("2:" + String(angulo) + ":" + String(d, 2));
  }

  // 4Ô∏è‚É£ √ìRBITA
  if (millis() >= nextOrbit) {
    nextOrbit = millis() + intervaloOrbit;
    enviarOrbita(millis());
  }
}


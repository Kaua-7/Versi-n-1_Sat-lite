import serial
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from tkinter import *
from tkinter import messagebox
import math
import time

# =================== Configuración puerto ===================
# Puerto serie hacia la estación de tierra (ajusta 'COM5' si es necesario)
device = 'COM5'   # ajusta a tu puerto
mySerial = serial.Serial(device, 9600, timeout=1)  # objeto Serial para comunicación

# =================== Variables de datos ===================
# Listas para almacenar lecturas de temperatura, humedad y eje de muestras
temperaturas = []
humedades = []
eje_x = []
# Lista para almacenar la media móvil (puede ser calculada en Python o recibida desde Arduino)
media_movil = []

# Flags/valores de control de alertas y parámetros
alerta_activa = False            # alerta basada en 3 últimas TEMPERATURAS (comportamiento original)
alerta_media_activa = False      # alerta nueva: basada en 3 últimas MEDIAS
limite_temp = 30.0               # límite por defecto para alertas
ventana_default = 10             # ventana por defecto para la media móvil
i = 0                            # contador de muestras
lectura_activa = False           # indica si el ciclo de lectura está activo

# Radar: almacena únicamente los últimos puntos (ángulo, distancia)
radar_angulos = []
radar_distancias = []
RADAR_MAX_POINTS = 3             # número máximo de puntos del radar a mostrar

# Modo de cálculo de la media: 'python' (local) o 'arduino' (remoto)
modo_media = "python"

# =================== Ventana principal ===================
# Crear la ventana principal de Tkinter y configurar título/tamaño
window = Tk()
window.title("Ground Station - Radar + Gráficas (v2.4)")
window.geometry("1400x850")

# =================== Figuras ===================
# Crear figura de matplotlib con subplots para temperatura, humedad, media y radar
fig = plt.figure(figsize=(10, 8))
ax1 = fig.add_subplot(3, 2, 1)           # gráfico temperatura
ax2 = fig.add_subplot(3, 2, 3)           # gráfico humedad
ax3 = fig.add_subplot(3, 2, 5)           # gráfico media móvil
ax_radar = fig.add_subplot(1, 2, 2, polar=True)  # radar polar para ultrasonidos

# --- Líneas iniciales (objetos de plot vacíos que luego actualizamos) ---
line_temp, = ax1.plot([], [], '-o', color='red', label="Temperatura")
ax1.set_title("Temperatura (°C)")
ax1.grid(True); ax1.legend()

line_hum, = ax2.plot([], [], '-s', color='blue', label="Humedad")
ax2.set_title("Humedad (%)")
ax2.grid(True); ax2.legend()

line_avg, = ax3.plot([], [], '-D', color='green', label="Media móvil")
ax3.set_title("Media móvil")
ax3.grid(True); ax3.legend()

# Configuración del radar (orientación y límites)
ax_radar.set_theta_zero_location('N')  # 0° en norte
ax_radar.set_theta_direction(-1)       # sentido horario
ax_radar.set_rlim(0, 400)              # rango radial del sensor
ax_radar.set_thetamin(0)               # ángulo mínimo del radar
ax_radar.set_thetamax(180)             # ángulo máximo del radar

# Integración de Matplotlib en Tkinter
canvas = FigureCanvasTkAgg(fig, master=window)
canvas.draw()
canvas.get_tk_widget().grid(row=0, column=0, rowspan=20, padx=10, pady=10)

# =================== Panel de controles ===================
# Frame lateral para controles y entradas del usuario
controls_frame = Frame(window)
controls_frame.grid(row=0, column=1, sticky=N, padx=12)

Label(controls_frame, text="Ground Station v2.4", font=("Courier", 18, "italic")).grid(row=0, column=0, pady=(0,10))

# --- Límite temperatura ---
# Entrada para ajustar el límite de temperatura que activa alertas
Label(controls_frame, text="Límite temperatura (°C):").grid(row=1, column=0, sticky=W)
limiteVar = StringVar(value=str(limite_temp))
Entry(controls_frame, textvariable=limiteVar, width=10).grid(row=2,column=0, sticky=W)

# --- Ventana media móvil ---
# Spinbox para elegir N de la media móvil (si se calcula localmente en Python)
Label(controls_frame, text="Ventana media móvil (N):").grid(row=3,column=0, sticky=W)
ventanaVar = IntVar(value=ventana_default)
Spinbox(controls_frame, from_=1, to=200, textvariable=ventanaVar, width=6).grid(row=4,column=0, sticky=W)

# --- Intervalo envío DHT ---
# Spinbox para enviar al satélite el intervalo de envío de DHT (en segundos)
Label(controls_frame, text="Intervalo envío DHT (s):").grid(row=5,column=0, sticky=W, pady=(6,0))
intervaloDHTVar = IntVar(value=3)
Spinbox(controls_frame, from_=1, to=3600, textvariable=intervaloDHTVar, width=6).grid(row=6,column=0, sticky=W)

def send_intervalo_dht():
    """Enviar comando al satélite para cambiar intervalo DHT (1:<segundos>)"""
    try:
        s = int(intervaloDHTVar.get())
        mySerial.write(f"1:{s}\n".encode())
        print("Enviado intervalo DHT:", s)
    except:
        # Mostrar error si el valor no es válido
        messagebox.showerror("Error", "Intervalo DHT inválido")

Button(controls_frame, text="Enviar intervalo DHT", command=send_intervalo_dht, width=18).grid(row=7,column=0,pady=(4,8))

# --- Intervalo envío ultrasonidos ---
# Spinbox para enviar al satélite el intervalo de barrido ultrasónico (en ms)
Label(controls_frame, text="Intervalo ultrasonidos (ms):").grid(row=8,column=0, sticky=W)
intervaloUltraVar = IntVar(value=500)
Spinbox(controls_frame, from_=50, to=10000, textvariable=intervaloUltraVar, width=8).grid(row=9,column=0, sticky=W)

def send_intervalo_ultra():
    """Enviar comando al satélite para cambiar intervalo ultrasónicos (7:<ms>)"""
    try:
        ms = int(intervaloUltraVar.get())
        mySerial.write(f"7:{ms}\n".encode())
        print("Enviado intervalo ultrasonidos (ms):", ms)
    except:
        messagebox.showerror("Error", "Intervalo ultrasonidos inválido")

Button(controls_frame, text="Enviar intervalo ultrasonidos", command=send_intervalo_ultra, width=18).grid(row=10,column=0,pady=(4,8))

# --- Modo media ---
# Radio buttons para elegir si la media se calcula en Python o Arduino
Label(controls_frame, text="Dónde calcular la media:").grid(row=11,column=0, sticky=W)
modoVar = StringVar(value="python")

def modo_media_changed():
    """
    Cambia el modo de cálculo de la media.
    Si se selecciona 'arduino', se envía 8:1 para activar el cálculo en el satélite
    y 9:N para establecer la ventana N en Arduino.
    """
    global modo_media
    modo_media = modoVar.get()
    if modo_media == "arduino":
        mySerial.write(b"8:1\n")
        time.sleep(0.05)
        n = int(ventanaVar.get())
        mySerial.write(f"9:{n}\n".encode())
        print("Modo media: ARDUINO, window N sent:", n)
    else:
        mySerial.write(b"8:0\n")
        print("Modo media: PYTHON")

Radiobutton(controls_frame, text="Python (local)", variable=modoVar, value="python", command=modo_media_changed).grid(row=12,column=0, sticky=W)
Radiobutton(controls_frame, text="Arduino (remoto)", variable=modoVar, value="arduino", command=modo_media_changed).grid(row=13,column=0, sticky=W)

# --- Ángulo servo manual ---
# Entrada para indicar ángulo manual; envía comando 2:<angulo>
Label(controls_frame, text="Ángulo servo (0-180°):").grid(row=14,column=0, sticky=W, pady=(8,0))
anguloVar = IntVar(value=0)
Entry(controls_frame, textvariable=anguloVar, width=6).grid(row=15,column=0, sticky=W)

def enviar_angulo():
    """Enviar ángulo manual al satélite (2:<angulo>)"""
    try:
        ang = int(anguloVar.get())
        if 0 <= ang <= 180:
            mySerial.write(f"2:{ang}\n".encode())
            print("Enviado ángulo:", ang)
        else:
            messagebox.showerror("Error", "Ángulo debe estar entre 0 y 180")
    except:
        messagebox.showerror("Error", "Ángulo inválido")

Button(controls_frame, text="Enviar ángulo", command=enviar_angulo, width=18, bg='cyan').grid(row=16,column=0,pady=(4,6))

# --- Barrido on/off ---
# Botones para activar o desactivar el barrido automático (6:1 / 6:0)
def activar_barrido():
    try:
        mySerial.write(b"6:1\n")
    except:
        pass

def desactivar_barrido():
    try:
        mySerial.write(b"6:0\n")
    except:
        pass

Button(controls_frame, text="Activar Barrido", command=activar_barrido, width=18, bg='green').grid(row=17,column=0,pady=3)
Button(controls_frame, text="Detener Barrido", command=desactivar_barrido, width=18, bg='red').grid(row=18,column=0,pady=3)

# --- Indicador alarma de MEDIA (nuevo) ---
# Etiqueta visual que indica si la alarma por medias está activa
Label(controls_frame, text="Estado alarma (medias):").grid(row=23, column=0, sticky=W, pady=(8,0))
alarma_media_label = Label(controls_frame, text="Normal", bg="lightgreen", width=18)
alarma_media_label.grid(row=24, column=0, pady=(2,8))

# --- Botones iniciar/parar/reset/reanudar ---
def IniciarClick():
    """
    Iniciar lectura: activa el flag lectura_activa y envía 'Iniciar' al satélite.
    Lanza el ciclo de lectura periódico.
    """
    global lectura_activa
    lectura_activa = True
    try: mySerial.write(b'Iniciar\n')
    except: pass
    ciclo_lectura()

def PararClick():
    """Parar lectura: desactiva el flag y manda 'Parar' al satélite."""
    global lectura_activa
    lectura_activa = False
    try: mySerial.write(b'Parar\n')
    except: pass

def ReanudarClick():
    """
    Reanudar lectura: activa flag, manda 'Iniciar' y lanza el ciclo de lectura.
    (Reanudar se implementa enviando el mismo comando 'Iniciar'.)
    """
    global lectura_activa
    lectura_activa = True
    try: mySerial.write(b'Iniciar\n')
    except: pass
    ciclo_lectura()

def ResetClick():
    """
    Reset gráfico: limpia todas las listas de datos y reactivar el barrido en satélite.
    También resetea las alertas y actualiza la interfaz.
    """
    global temperaturas, humedades, eje_x, media_movil, i, radar_angulos, radar_distancias, alerta_activa, alerta_media_activa
    temperaturas=[]; humedades=[]; eje_x=[]; media_movil=[]; i=0
    radar_angulos=[]; radar_distancias=[]
    alerta_activa = False
    alerta_media_activa = False
    alarma_media_label.config(text="Normal", bg="lightgreen")
    try: mySerial.write(b'6:1\n')  # reactivar barrido en satélite
    except: pass
    actualizar_graficas()

Button(controls_frame, text="Iniciar", bg='green', fg='white', command=IniciarClick, width=18).grid(row=19,column=0,pady=(8,2))
Button(controls_frame, text="Parar", bg='red', fg='white', command=PararClick, width=18).grid(row=20,column=0,pady=2)
Button(controls_frame, text="Reanudar", bg='yellow', fg='black', command=ReanudarClick, width=18).grid(row=21,column=0,pady=2)
Button(controls_frame, text="Reset (reactiva barrido)", bg='gray', fg='white', command=ResetClick, width=18).grid(row=22,column=0,pady=(6,2))

# =================== Funciones de graficado ===================
def actualizar_graficas():
    """
    Actualiza las tres gráficas (temperatura, humedad, media) y el radar.
    - Ajusta límites y recalcula la media local si es necesario.
    - Redibuja el radar con los últimos puntos disponibles.
    """
    # Temperatura/humedad/media
    line_temp.set_data(eje_x, temperaturas)
    line_hum.set_data(eje_x, humedades)

    # Si el modo es Python, recalcular completamente la media_movil según la ventana actual
    if modoVar.get() == "python":
        N = max(1, int(ventanaVar.get()))
        media_movil.clear()
        for idx in range(len(temperaturas)):
            slice_ = temperaturas[max(0, idx - N + 1): idx + 1]
            media_movil.append(sum(slice_) / len(slice_))
    # En modo Arduino se asume que media_movil se rellena en leer_serial con A:<avg>

    # Preparar datos para plot (reemplazar NaN/None por 0 para que matplotlib no falle)
    media_plot = [m if (m is not None and not (isinstance(m, float) and math.isnan(m))) else 0 for m in media_movil]
    line_avg.set_data(eje_x[:len(media_plot)], media_plot)

    # Actualizar autoscaling de ejes
    ax1.relim(); ax1.autoscale_view()
    ax2.relim(); ax2.autoscale_view()
    ax3.relim(); ax3.autoscale_view()

    # Radar: últimos puntos (polar)
    ax_radar.clear()
    ax_radar.set_theta_zero_location('N')
    ax_radar.set_theta_direction(-1)
    ax_radar.set_rlim(0, 400)
    ax_radar.set_thetamin(0)
    ax_radar.set_thetamax(180)
    ax_radar.set_title("Radar ultrasónico (últimos 3 puntos)")

    if radar_angulos:
        # Convertir ángulos a radianes y dibujar puntos
        theta = [math.radians(a) for a in radar_angulos]
        r = radar_distancias
        for idx_pt in range(len(theta)):
            if idx_pt == len(theta) - 1:
                # último punto (más reciente): más visible (rojo)
                ax_radar.scatter([theta[idx_pt]], [r[idx_pt]], c='red', s=140, zorder=4, edgecolors='k')
            else:
                ax_radar.scatter([theta[idx_pt]], [r[idx_pt]], c='orange', s=80, zorder=3, edgecolors='k')
        # unir puntos con una línea fina
        ax_radar.plot(theta, r, color='orange', linewidth=1, zorder=2)

    # Forzar redibujado en la interfaz
    canvas.draw_idle()

# =================== Funciones de lectura serie ===================
def leer_serial():
    """
    Lee todas las líneas disponibles desde el puerto serie y las procesa:
    - Mensajes '1:...' => temperatura/humedad (posible campo A:<avg>)
    - Mensajes '2:...' => radar ultrasónico (ángulo, distancia)
    - Otros códigos (3,5,6) se muestran en consola (fallos o mensajes)
    """
    global i, alerta_activa, alerta_media_activa, limite_temp
    try:
        while mySerial.in_waiting > 0:
            # Leer línea y sanear
            line = mySerial.readline().decode('utf-8', errors='ignore').strip()
            if not line:
                continue
            print("Serie <-", line)
            trozos = line.split(':')

            # --- DHT: 1:<temp>:<hum> o 1:<temp>:<hum>:A:<avg> ---
            if len(trozos) >= 3 and trozos[0] == '1':
                try:
                    temperatura = float(trozos[1])
                    hum = float(trozos[2])
                except:
                    # salto si valores no son numéricos
                    continue

                # Añadir a listas y actualizar contador
                eje_x.append(i)
                temperaturas.append(temperatura)
                humedades.append(hum)
                i += 1

                # manejar media dependiendo del modo seleccionado
                if modoVar.get() == "arduino":
                    # intentar leer campo A:<avg> enviado por Arduino
                    if len(trozos) >= 5 and trozos[3] == 'A':
                        try:
                            avg = float(trozos[4])
                            media_movil.append(avg)
                        except:
                            # si no se puede parsear, fallback: calcular local según ventana
                            N = max(1, int(ventanaVar.get()))
                            if len(temperaturas) >= N:
                                media_movil.append(sum(temperaturas[-N:]) / N)
                            else:
                                media_movil.append(float('nan'))
                    else:
                        # Arduino seleccionado pero no envía avg -> fallback local
                        N = max(1, int(ventanaVar.get()))
                        if len(temperaturas) >= N:
                            media_movil.append(sum(temperaturas[-N:]) / N)
                        else:
                            media_movil.append(float('nan'))
                else:
                    # modo python: calcular media local usando ventana actual
                    N = max(1, int(ventanaVar.get()))
                    if len(temperaturas) >= N:
                        media_movil.append(sum(temperaturas[-N:]) / N)
                    else:
                        media_movil.append(float('nan'))

                # --- Alerta existente: 3 últimas TEMPERATURAS individuales > límite ---
                if len(temperaturas) >= 3:
                    ult3 = temperaturas[-3:]
                    try:
                        limite = float(limiteVar.get())
                    except:
                        limite = limite_temp
                    if all(x > limite for x in ult3) and not alerta_activa:
                        alerta_activa = True
                        messagebox.showwarning("Alerta", f"Las 3 últimas temperaturas superan {limite} °C")
                    elif not all(x > limite for x in ult3) and alerta_activa:
                        alerta_activa = False

                # --- Alerta NUEVA: 3 últimas MEDIAS > límite -> indicador de peligro ---
                # Sacar solo medias válidas (no NaN) y comprobar las 3 últimas
                medias_validas = [m for m in media_movil if (m is not None and not (isinstance(m, float) and math.isnan(m)))]
                if len(medias_validas) >= 3:
                    last3_medias = medias_validas[-3:]
                    try:
                        limite = float(limiteVar.get())
                    except:
                        limite = limite_temp
                    if all(m > limite for m in last3_medias):
                        if not alerta_media_activa:
                            alerta_media_activa = True
                            # cambiar etiqueta visual y mostrar mensaje emergente
                            alarma_media_label.config(text="Peligro", bg="red")
                            messagebox.showwarning("Alerta MEDIA", f"Las 3 últimas MEDIAS superan {limite} °C")
                    else:
                        if alerta_media_activa:
                            alerta_media_activa = False
                            alarma_media_label.config(text="Normal", bg="lightgreen")

            # --- Radar ultrasónico: 2:<angulo>:<distancia> ---
            elif len(trozos) >= 3 and trozos[0] == '2':
                try:
                    ang = float(trozos[1])
                    dist = float(trozos[2])
                except:
                    # datos inválidos -> ignorar
                    continue
                # validar rango de ángulo
                if ang < 0 or ang > 180:
                    continue
                # almacenar y mantener solo los últimos RADAR_MAX_POINTS
                radar_angulos.append(ang)
                radar_distancias.append(dist)
                while len(radar_angulos) > RADAR_MAX_POINTS:
                    radar_angulos.pop(0)
                    radar_distancias.pop(0)

            # --- Otros mensajes (códigos de estado / fallos) ---
            else:
                if trozos[0] == '3':
                    # fallo DHT reportado por satélite
                    print("Satélite: fallo DHT")
                elif trozos[0] == '5':
                    # mensajes informativos / ACKs del satélite
                    print("Satélite msg:", ":".join(trozos[1:]))
                elif trozos[0] == '6':
                    # fallo sensor distancia reportado por satélite
                    print("Satélite: fallo sensor distancia")
                else:
                    # mensaje desconocido -> imprimir para depuración
                    print("Otro mensaje:", line)

            # actualizar graficas tras procesar cada paquete
            actualizar_graficas()

    except serial.SerialException as e:
        # manejar excepción de puerto serie (ej. desconexión)
        print("Error puerto serie:", e)

def ciclo_lectura():
    """Ciclo periódico que lee serie mientras lectura_activa sea True."""
    if lectura_activa:
        leer_serial()
        # volver a programar ejecución en 200 ms
        window.after(200, ciclo_lectura)

# =================== Cierre ventana ===================
def on_close():
    """Callback para cierre de ventana: cierra puerto y destruye ventana."""
    global lectura_activa
    lectura_activa = False
    try:
        mySerial.close()
    except:
        pass
    window.destroy()

# Asociar callback de cierre y arrancar loop Tkinter
window.protocol("WM_DELETE_WINDOW", on_close)
window.mainloop()

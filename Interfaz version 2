import serial
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from tkinter import *
from tkinter import messagebox
import math
import time

# =================== Configuración puerto ===================
# Puerto serie hacia la estación de tierra (ajusta 'COM5' si es necesario)
device = 'COM5'   # ajusta a tu puerto
mySerial = serial.Serial(device, 9600, timeout=1)  # objeto Serial para comunicación

# =================== Variables de datos ===================
# Listas para almacenar lecturas de temperatura, humedad y eje de muestras
temperaturas = []
humedades = []
eje_x = []
# Lista para almacenar la media móvil (puede ser calculada en Python o recibida desde Arduino)
media_movil = []

# Flags/valores de control de alertas y parámetros
alerta_activa = False            # alerta basada en 3 últimas TEMPERATURAS (comportamiento original)
alerta_media_activa = False      # alerta nueva: basada en 3 últimas MEDIAS
limite_temp = 30.0               # límite por defecto para alertas
ventana_default = 10             # ventana por defecto para la media móvil
i = 0                            # contador de muestras
lectura_activa = False           # indica si el ciclo de lectura está activo

# Radar: almacena únicamente los últimos puntos (ángulo, distancia)
radar_angulos = []
radar_distancias = []
RADAR_MAX_POINTS = 3             # número máximo de puntos del radar a mostrar

# Modo de cálculo de la media: 'python' (local) o 'arduino' (remoto)
modo_media = "python"

# =================== Ventana principal ===================
# Crear la ventana principal de Tkinter y configurar título/tamaño
window = Tk()
window.title("Ground Station - Radar + Gráficas (v2.4)")
window.geometry("1400x850")

# =================== Figuras ===================
# Crear figura de matplotlib con subplots para temperatura, humedad, media y radar
fig = plt.figure(figsize=(10, 8))
ax1 = fig.add_subplot(3, 2, 1)           # gráfico temperatura
ax2 = fig.add_subplot(3, 2, 3)           # gráfico humedad
ax3 = fig.add_subplot(3, 2, 5)           # gráfico media móvil
ax_radar = fig.add_subplot(1, 2, 2, polar=True)  # radar polar para ultrasonidos

# --- Líneas iniciales (objetos de plot vacíos que luego actualizamos) ---
line_temp, = ax1.plot([], [], '-o', color='red', label="Temperatura")
ax1.set_title("Temperatura (°C)")
ax1.grid(True); ax1.legend()

line_hum, = ax2.plot([], [], '-s', color='blue', label="Humedad")
ax2.set_title("Humedad (%)")
ax2.grid(True); ax2.legend()

line_avg, = ax3.plot([], [], '-D', color='green', label="Media móvil")
ax3.set_title("Media móvil")
ax3.grid(True); ax3.legend()

# Configuración del radar (orientación y límites)
ax_radar.set_theta_zero_location('N')  # 0° en norte
ax_radar.set_theta_direction(-1)       # sentido horario
ax_radar.set_rlim(0, 400)              # rango radial del sensor
ax_radar.set_thetamin(0)               # ángulo mínimo del radar
ax_radar.set_thetamax(180)             # ángulo máximo del radar

# Integración de Matplotlib en Tkinter
canvas = FigureCanvasTkAgg(fig, master=window)
canvas.draw()
canvas.get_tk_widget().grid(row=0, column=0, rowspan=20, padx=10, pady=10)

# =================== Panel de controles ===================
# Frame lateral para controles y entradas del usuario
controls_frame = Frame(window)
controls_frame.grid(row=0, column=1, sticky=N, padx=12)

Label(controls_frame, text="Ground Station v2.4", font=("Courier", 18, "italic")).grid(row=0, column=0, pady=(0,10))

# --- Límite temperatura ---
# Entrada para ajustar el límite de temperatura que activa alertas
Label(controls_frame, text="Límite temperatura (°C):").grid(row=1, column=0, sticky=W)
limiteVar = StringVar(value=str(limite_temp))
Entry(controls_frame, textvariable=limiteVar, width=10).grid(row=2,column=0, sticky=W)

# --- Ventana media móvil ---
# Spinbox para elegir N de la media móvil (si se calcula localmente en Python)
Label(controls_frame, text="Ventana media móvil (N):").grid(row=3,column=0, sticky=W)
ventanaVar = IntVar(value=ventana_default)
Spinbox(controls_frame, from_=1, to=200, textvariable=ventanaVar, width=6).grid(row=4,column=0, sticky=W)

# --- Intervalo envío DHT ---
# Spinbox para enviar al satélite el intervalo de envío de DHT (en segundos)
Label(controls_frame, text="Intervalo envío DHT (s):").grid(row=5,column=0, sticky=W, pady=(6,0))
intervaloDHTVar = IntVar(value=3)
Spinbox(controls_frame, from_=1, to=3600, textvariable=intervaloDHTVar, width=6).grid(row=6,column=0, sticky=W)

def send_intervalo_dht():
    """Enviar comando al satélite para cambiar intervalo DHT (1:<segundos>)"""
    try:
        s = int(intervaloDHTVar.get())
        mySerial.write(f"1:{s}\n".encode())
        print("Enviado intervalo DHT:", s)
    except:
        # Mostrar error si el valor no es válido
        messagebox.showerror("Error", "Intervalo DHT inválido")

Button(controls_frame, text="Enviar intervalo DHT", command=send_intervalo_dht, width=18).grid(row=7,column=0,pady=(4,8))

# --- Intervalo envío ultrasonidos ---
# Spinbox para enviar al satélite el intervalo de barrido ultrasónico (en ms)
Label(controls_frame, text="Intervalo ultrasonidos (ms):").grid(row=8,column=0, sticky=W)
intervaloUltraVar = IntVar(value=500)
Spinbox(controls_frame, from_=50, to=10000, textvariable=intervaloUltraVar, width=8).grid(row=9,column=0, sticky=W)

def send_intervalo_ultra():
    """Enviar comando al satélite para cambiar intervalo ultrasónicos (7:<ms>)"""
    try:
        ms = int(intervaloUltraVar.get())
        mySerial.write(f"7:{ms}\n".encode())
        print("Enviado intervalo ultrasonidos (ms):", ms)
    except:
        messagebox.showerror("Error", "Intervalo ultrasonidos inválido")

Button(controls_frame, text="Enviar intervalo ultrasonidos", command=send_intervalo_ultra, width=18).grid(row=10,column=0,pady=(4,8))

# --- Modo media ---
# Radio buttons para elegir si la media se calcula en Python o Arduino
Label(controls_frame, text="Dónde calcular la media:").grid(row=11,column=0, sticky=W)
modoVar = StringVar(value="python")

def modo_media_changed():
    """
    Cambia el modo de cálculo de la media.
    Si se selecciona 'arduino', se envía 8:1 para activar el cálculo en el satélite
    y 9:N para establecer la ventana N en Arduino.
    """
    global modo_media
    modo_media = modoVar.get()
    if modo_media == "arduino":
        mySerial.write(b"8:1\n")
        time.sleep(0.05)
        n = int(ventanaVar.get())
        mySerial.write(f"9:{n}\n".encode())
        print("Modo media: ARDUINO, window N sent:", n)
    else:
        mySerial.write(b"8:0\n")
        print("Modo media: PYTHON")

Radiobutton(controls_frame, text="Python (local)", variable=modoVar, value="python", command=modo_media_changed).grid(row=12,column=0, sticky=W)
Radiobutton(controls_frame, text="Arduino (remoto)", variable=modoVar, value="arduino", command=modo_media_changed).grid(row=13,column=0, sticky=W)

# --- Ángulo servo manual ---
# Entrada para indicar ángulo manual; envía comando 2:<angulo>
Label(controls_frame, text="Ángulo servo (0-180°):").grid(row=14,column=0, sticky=W, pady=(8,0))
anguloVar = IntVar(value=0)
Entry(controls_frame, textvariable=anguloVar, width=6).grid(row=15,column=0, sticky=W)

def enviar_angulo():
    """Enviar ángulo manual al satélite (2:<angulo>)"""
    try:
        ang = int(anguloVar.get())
        if 0 <= ang <= 180:
            mySerial.write(f"2:{ang}\n".encode())
            print("Enviado ángulo:", ang)
        else:
            messagebox.showerror("Error", "Ángulo debe estar entre 0 y 180")
    except:
        messagebox.showerror("Error", "Ángulo inválido")

Button(controls_frame, text="Enviar ángulo", command=enviar_angulo, width=18, bg='cyan').grid(row=16,column=0,pady=(4,6))

# --- Barrido on/off ---
# Botones para activar o desactivar el barrido automático (6:1 / 6:0)
def activar_barrido():
    try:
        mySerial.write(b"6:1\n")
    except:
        pass

def desactivar_barrido():
    try:
        mySerial.write(b"6:0\n")
    except:
        pass

Button(controls_frame, text="Activar Barrido", command=activar_barrido, width=18, bg='green').grid(row=17,column=0,pady=3)
Button(controls_frame, text="Detener Barrido", command=desactivar_barrido, width=18, bg='red').grid(row=18,column=0,pady=3)

# --- Indicador alarma de MEDIA (nuevo) ---
# Etiqueta visual que indica si la alarma por medias está activa
Label(controls_frame, text="Estado alarma (medias):").grid(row=23, column=0, sticky=W, pady=(8,0))
alarma_media_label = Label(controls_frame, text="Normal", bg="lightgreen", width=18)
alarma_media_label.grid(row=24, column=0, pady=(2,8))

# --- Botones iniciar/parar/reset/reanudar ---
def IniciarClick():
    """
    Iniciar lectura: activa el flag lectura_activa y envía 'Iniciar' al satélite.
    Lanza el ciclo de lectura periódico.
    """
    global lectura_activa
    lectura_activa = True
    try: mySerial.write(b'Iniciar\n')
    except: pass
    ciclo_lectura()

def PararClick():
    """Parar lectura: desactiva el flag y manda 'Parar' al satélite."""
    global lectura_activa
    lectura_activa = False
    try: mySerial.write(b'Parar\n')
    except: pass

def ReanudarClick():
    """
    Reanudar lectura: activa flag, manda 'Iniciar' y lanza el ciclo de lectura.
    (Reanudar se implementa enviando el mismo comando 'Iniciar'.)
    """
    global lectura_activa
    lectura_activa = True
    try: mySerial.write(b'Iniciar\n')
    except: pass
    ciclo_lectura()

def ResetClick():
    """
    Reset gráfico: limpia todas las listas de datos y reactivar el barrido en satélite.
    También resetea las alertas y actualiza la interfaz.
    """
    global temperaturas, humedades, eje_x, media_movil, i, radar_angulos, radar_distancias, alerta_activa, alerta_media_activa
    temperaturas=[]; humedades=[]; eje_x=[]; media_movil=[]; i=0
    radar_angulos=[]; radar_distancias=[]
    alerta_activa = False
    alerta_media_activa = False
    alarma_media_label.config(text="Normal", bg="lightgreen")
    try: mySerial.write(b'6:1\n')  # reactivar barrido en satélite
    except: pass
    actualizar_graficas()

Button(controls_frame, text="Iniciar", bg='green', fg='white', command=IniciarClick, width=18).grid(row=19,column=0,pady=(8,2))
Button(controls_frame, text="Parar", bg='red', fg='white', command=PararClick, width=18).grid(row=20,column=0,pady=2)
Button(controls_frame, text="Reanudar", bg='yellow', fg='black', command=ReanudarClick, width=18).grid(row=21,column=0,pady=2)
Button(controls_frame, text="Reset (reactiva barrido)", bg='gray', fg='white', command=ResetClick, width=18).grid(row=22,column=0,pady=(6,2))

# =================== Funciones de graficado ===================
def actualizar_graficas():
    """
    Actualiza las tres gráficas (temperatura, humedad, media) y el radar.
    - Ajusta límites y recalcula la media local si es necesario.
    - Redibuja el radar con los últimos puntos disponibles.
    """
    # Temperatura/humedad/media
    line_temp.set_data(eje_x, temperaturas)
    line_hum.set_data(eje_x, humedades)

    # Si el modo es Python, recalcular completamente la media_movil según la ventana actual
    if modoVar.get() == "python":
        N = max(1, int(ventanaVar.get()))
        media_movil.clear()
        for idx in range(len(temperaturas)):
            slice_ = temperaturas[max(0, idx - N + 1): idx + 1]
            media_movil.append(sum(slice_) / len(slice_))
    # En modo Arduino se asume que media_movil se rellena en leer_serial con A:<avg>

    # Preparar datos para plot (reemplazar NaN/None por 0 para que matplotlib no falle)
    media_plot = [m if (m is not None and not (isinstance(m, float) and math.isnan(m))) else 0 for m in media_movil]
    line_avg.set_data(eje_x[:len(media_plot)], media_plot)

    # Actualizar autoscaling de ejes
    ax1.relim(); ax1.autoscale_view()
    ax2.relim(); ax2.autoscale_view()
    ax3.relim(); ax3.autoscale_view()

    # Radar: últimos puntos (polar)
    ax_radar.clear()
    ax_radar.set_theta_zero_location('N')
    ax_radar.set_theta_direction(-1)
    ax_radar.set_rlim(0, 400)
    ax_radar.set_thetamin(0)
    ax_radar.set_thetamax(180)
    ax_radar.set_title("Radar ultrasónico (últimos 3 puntos)")

    if radar_angulos:
        # Convertir ángulos a radianes y dibujar puntos
        theta = [math.radians(a) for a in radar_angulos]
        r = radar_distancias
        for idx_pt in range(len(theta)):
            if idx_pt == len(theta) - 1:
                # último punto (más reciente): más visible (rojo)
                ax_radar.scatter([theta[idx_pt]], [r[idx_pt]], c='red', s=140, zorder=4, edgecolors='k')
            else:
                ax_radar.scatter([theta[idx_pt]], [r[idx_pt]], c='orange', s=80, zorder=3, edgecolors='k')
        # unir puntos con una línea fina
        ax_radar.plot(theta, r, color='orange', linewidth=1, zorder=2)

    # Forzar redibujado en la interfaz
    canvas.draw_idle()

# =================== Funciones de lectura serie ===================
def leer_serial():
    """
    Lee todas las líneas disponibles desde el puerto serie y las procesa:
    - Mensajes '1:...' => temperatura/humedad (posible campo A:<avg>)
    - Mensajes '2:...' => radar ultrasónico (ángulo, distancia)
    - Otros códigos (3,5,6) se muestran en consola (fallos o mensajes)
    """
    global i, alerta_activa, alerta_media_activa, limite_temp
    try:
        while mySerial.in_waiting > 0:
            # Leer línea y sanear
            line = mySerial.readline().decode('utf-8', errors='ignore').strip()
            if not line:
                continue
            print("Serie <-", line)
            trozos = line.split(':')

            # --- DHT: 1:<temp>:<hum> o 1:<temp>:<hum>:A:<avg> ---
            if len(trozos) >= 3 and trozos[0] == '1':
                try:
                    temperatura = float(trozos[1])
                    hum = float(trozos[2])
                except:
                    # salto si valores no son numéricos
                    continue

                # Añadir a listas y actualizar contador
                eje_x.append(i)
                temperaturas.append(temperatura)
                humedades.append(hum)
                i += 1

                # manejar media dependiendo del modo seleccionado
                if modoVar.get() == "arduino":
                    # intentar leer campo A:<avg> enviado por Arduino
                    if len(trozos) >= 5 and trozos[3] == 'A':
                        try:
                            avg = float(trozos[4])
                            media_movil.append(avg)
                        except:
                            # si no se puede parsear, fallback: calcular local según ventana
                            N = max(1, int(ventanaVar.get()))
                            if len(temperaturas) >= N:
                                media_movil.append(sum(temperaturas[-N:]) / N)
                            else:
                                media_movil.append(float('nan'))
                    else:
                        # Arduino seleccionado pero no envía avg -> fallback local
                        N = max(1, int(ventanaVar.get()))
                        if len(temperaturas) >= N:
                            media_movil.append(sum(temperaturas[-N:]) / N)
                        else:
                            media_movil.append(float('nan'))
                else:
                    # modo python: calcular media local usando ventana actual
                    N = max(1, int(ventanaVar.get()))
                    if len(temperaturas) >= N:
                        media_movil.append(sum(temperaturas[-N:]) / N)
                    else:
                        media_movil.append(float('nan'))

                # --- Alerta existente: 3 últimas TEMPERATURAS individuales > límite ---
                if len(temperaturas) >= 3:
                    ult3 = temperaturas[-3:]
                    try:
                        limite = float(limiteVar.get())
                    except:
                        limite = limite_temp
                    if all(x > limite for x in ult3) and not alerta_activa:
                        alerta_activa = True
                        messagebox.showwarning("Alerta", f"Las 3 últimas temperaturas superan {limite} °C")
                    elif not all(x > limite for x in ult3) and alerta_activa:
                        alerta_activa = False

                # --- Alerta NUEVA: 3 últimas MEDIAS > límite -> indicador de peligro ---
                # Sacar solo medias válidas (no NaN) y comprobar las 3 últimas
                medias_validas = [m for m in media_movil if (m is not None and not (isinstance(m, float) and math.isnan(m)))]
                if len(medias_validas) >= 3:
                    last3_medias = medias_validas[-3:]
                    try:
                        limite = float(limiteVar.get())
                    except:
                        limite = limite_temp
                    if all(m > limite for m in last3_medias):
                        if not alerta_media_activa:
                            alerta_media_activa = True
                            # cambiar etiqueta visual y mostrar mensaje emergente
                            alarma_media_label.config(text="Peligro", bg="red")
                            messagebox.showwarning("Alerta MEDIA", f"Las 3 últimas MEDIAS superan {limite} °C")
                    else:
                        if alerta_media_activa:
                            alerta_media_activa = False
                            alarma_media_label.config(text="Normal", bg="lightgreen")

            # --- Radar ultrasónico: 2:<angulo>:<distancia> ---
            elif len(trozos) >= 3 and trozos[0] == '2':
                try:
                    ang = float(trozos[1])
                    dist = float(trozos[2])
                except:
                    # datos inválidos -> ignorar
                    continue
                # validar rango de ángulo
                if ang < 0 or ang > 180:
                    continue
                # almacenar y mantener solo los últimos RADAR_MAX_POINTS
                radar_angulos.append(ang)
                radar_distancias.append(dist)
                while len(radar_angulos) > RADAR_MAX_POINTS:
                    radar_angulos.pop(0)
                    radar_distancias.pop(0)

            # --- Otros mensajes (códigos de estado / fallos) ---
            else:
                if trozos[0] == '3':
                    # fallo DHT reportado por satélite
                    print("Satélite: fallo DHT")
                elif trozos[0] == '5':
                    # mensajes informativos / ACKs del satélite
                    print("Satélite msg:", ":".join(trozos[1:]))
                elif trozos[0] == '6':
                    # fallo sensor distancia reportado por satélite
                    print("Satélite: fallo sensor distancia")
                else:
                    # mensaje desconocido -> imprimir para depuración
                    print("Otro mensaje:", line)

            # actualizar graficas tras procesar cada paquete
            actualizar_graficas()

    except serial.SerialException as e:
        # manejar excepción de puerto serie (ej. desconexión)
        print("Error puerto serie:", e)

def ciclo_lectura():
    """Ciclo periódico que lee serie mientras lectura_activa sea True."""
    if lectura_activa:
        leer_serial()
        # volver a programar ejecución en 200 ms
        window.after(200, ciclo_lectura)

# =================== Cierre ventana ===================
def on_close():
    """Callback para cierre de ventana: cierra puerto y destruye ventana."""
    global lectura_activa
    lectura_activa = False
    try:
        mySerial.close()
    except:
        pass
    window.destroy()

# Asociar callback de cierre y arrancar loop Tkinter
window.protocol("WM_DELETE_WINDOW", on_close)
window.mainloop()





CODIGO COMENTADO
import serial
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from tkinter import *
from tkinter import messagebox
import math
import time

# =================== Configuración puerto ===================
# Aquí se define el puerto serie donde está conectada la estación de tierra
# Cambia 'COM5' por el puerto correcto en tu sistema (ej. '/dev/ttyUSB0' en Linux).
device = 'COM5'  # Cambia al puerto correcto si hace falta
# Se abre el puerto serie con 9600 baudios y timeout 1s.
# El timeout evita bloqueos en read; in_waiting se usa para ver si hay bytes.
mySerial = serial.Serial(device, 9600, timeout=1)

# =================== Variables de datos ===================
# Listas para almacenar lecturas de DHT y eje temporal (muestras)
temperaturas = []
humedades = []
eje_x = []
media_movil = []

# Flags y parámetros de control de alertas y ventanas
alerta_activa = False           # alerta basada en 3 últimas temperaturas individuales
alerta_media_activa = False     # alerta basada en 3 últimas medias móviles
limite_temp = 30.0              # umbral por defecto (°C)
ventana_default = 10            # N por defecto para media móvil
i = 0                           # contador incremental de muestras (eje_x)
lectura_activa = False          # flag que indica si el bucle de lectura está activo

# Listas para radar (ultrasonidos): ángulos y distancias
radar_angulos = []
radar_distancias = []
RADAR_MAX_POINTS = 3   # cuántos puntos mantenemos en el radar (historico corto)
last_angle_received = None  # almacena el último ángulo válido recibido
modo_media = "python"  # 'python' (calcular media localmente) o 'arduino' (recibida desde Arduino)

# Control de intervalo DHT en Python (evitar procesar/mostrar cada paquete si llegan muy rápido)
# Se compara con time.time()*1000 para decidir si aceptar una lectura DHT recibida.
last_dht_accepted_ms = 0

# =================== Ventana principal (Tkinter) ===================
# Creamos la ventana principal de la interfaz con título y tamaño.
window = Tk()
window.title("Ground Station - Radar + Gráficas (v2.4)")
window.geometry("1400x850")

# =================== Figuras (Matplotlib) ===================
# Creamos la figura con subplots: temperatura, humedad, media y radar polar.
fig = plt.figure(figsize=(10, 8))
ax1 = fig.add_subplot(3, 2, 1)                   # temperatura
ax2 = fig.add_subplot(3, 2, 3)                   # humedad
ax3 = fig.add_subplot(3, 2, 5)                   # media móvil
ax_radar = fig.add_subplot(1, 2, 2, polar=True)  # radar polar (ultrasonidos)

# =================== Líneas de gráficas (líneas continuas, sin puntos) ===================
# Inicializamos las "líneas" en blanco; los objetos line_* nos permiten
# actualizar los datos más tarde con set_data(...) sin recrear el plot.
line_temp, = ax1.plot([], [], linestyle='-', marker=None, color='red', label="Temperatura")
ax1.set_title("Temperatura (°C)")
ax1.grid(True)
ax1.legend()

line_hum, = ax2.plot([], [], linestyle='-', marker=None, color='blue', label="Humedad")
ax2.set_title("Humedad (%)")
ax2.grid(True)
ax2.legend()

line_avg, = ax3.plot([], [], linestyle='-', marker=None, color='green', label="Media móvil")
ax3.set_title("Media móvil")
ax3.grid(True)
ax3.legend()

# =================== Config radar ===================
# Ajustes visuales del radar: fondo, orientación y límites radiales.
ax_radar.set_facecolor("black")
ax_radar.set_theta_zero_location('N')   # 0° arriba (Norte)
ax_radar.set_theta_direction(-1)        # sentido horario para ángulos
ax_radar.set_rlim(0, 400)               # rango radial (cm) acorde a HC-SR04
ax_radar.set_thetamin(0)
ax_radar.set_thetamax(180)              # solo medio arco (0..180)

# Integración de Matplotlib dentro de Tkinter
canvas = FigureCanvasTkAgg(fig, master=window)
canvas.draw()
canvas.get_tk_widget().grid(row=0, column=0, rowspan=20, padx=10, pady=10)

# =================== Panel de controles (Tkinter) ===================
controls_frame = Frame(window)
controls_frame.grid(row=0, column=1, sticky=N, padx=12)

# --- Encabezado ---
Label(controls_frame, text="Ground Station v2.4", font=("Courier", 18, "italic")).grid(row=0, column=0, pady=(0,10))

# --- Límite de temperatura (entrada de usuario) ---
Label(controls_frame, text="Límite temperatura (°C):").grid(row=1, column=0, sticky=W)
limiteVar = StringVar(value=str(limite_temp))
Entry(controls_frame, textvariable=limiteVar, width=10).grid(row=2,column=0, sticky=W)

# --- Ventana N para media móvil ---
Label(controls_frame, text="Ventana media móvil (N):").grid(row=3,column=0, sticky=W)
ventanaVar = IntVar(value=ventana_default)
Spinbox(controls_frame, from_=1, to=200, textvariable=ventanaVar, width=6).grid(row=4,column=0, sticky=W)

# --- Intervalo DHT (el usuario pide cada cuántos segundos desea recibir/aceptar lecturas) ---
Label(controls_frame, text="Intervalo envío DHT (s):").grid(row=5,column=0, sticky=W, pady=(6,0))
intervaloDHTVar = IntVar(value=3)
Spinbox(controls_frame, from_=1, to=3600, textvariable=intervaloDHTVar, width=6).grid(row=6,column=0, sticky=W)

def send_intervalo_dht():
    """
    Envía al satélite/Arduino el comando para cambiar el intervalo de envío DHT.
    Formato: "1:<segundos>\n"
    """
    try:
        s = int(intervaloDHTVar.get())
        mySerial.write(f"1:{s}\n".encode())
        print("Enviado intervalo DHT:", s)
    except Exception:
        # Mensaje de error si el valor no es válido
        messagebox.showerror("Error", "Intervalo DHT inválido")

Button(controls_frame, text="Enviar intervalo DHT", command=send_intervalo_dht, width=18).grid(row=7,column=0,pady=(4,8))

# --- Intervalo ultrasonidos (ms) ---
Label(controls_frame, text="Intervalo ultrasonidos (ms):").grid(row=8,column=0, sticky=W)
intervaloUltraVar = IntVar(value=500)
Spinbox(controls_frame, from_=50, to=10000, textvariable=intervaloUltraVar, width=8).grid(row=9,column=0, sticky=W)

def send_intervalo_ultra():
    """
    Envía al satélite/Arduino el comando para cambiar el intervalo de barrido ultrasónico.
    Formato: "7:<ms>\n"
    """
    try:
        ms = int(intervaloUltraVar.get())
        mySerial.write(f"7:{ms}\n".encode())
        print("Enviado intervalo ultrasonidos (ms):", ms)
    except Exception:
        messagebox.showerror("Error", "Intervalo ultrasonidos inválido")

Button(controls_frame, text="Enviar intervalo ultrasonidos", command=send_intervalo_ultra, width=18).grid(row=10,column=0,pady=(4,8))

# --- Dónde calcular la media: Python o Arduino ---
Label(controls_frame, text="Dónde calcular la media:").grid(row=11,column=0, sticky=W)
modoVar = StringVar(value="python")

def modo_media_changed():
    """
    Al cambiar modo, se notifica al Arduino con 8:1 (activar) o 8:0 (desactivar),
    y además se envía la ventana N con 9:N cuando se selecciona Arduino.
    """
    global modo_media
    modo_media = modoVar.get()
    if modo_media == "arduino":
        mySerial.write(b"8:1\n")
        # pequeño retardo para que Arduino procese el comando antes del siguiente
        time.sleep(0.05)
        n = int(ventanaVar.get())
        mySerial.write(f"9:{n}\n".encode())
        print("Modo media: ARDUINO, window N sent:", n)
    else:
        mySerial.write(b"8:0\n")
        print("Modo media: PYTHON")

Radiobutton(controls_frame, text="Python (local)", variable=modoVar, value="python", command=modo_media_changed).grid(row=12,column=0, sticky=W)
Radiobutton(controls_frame, text="Arduino (remoto)", variable=modoVar, value="arduino", command=modo_media_changed).grid(row=13,column=0, sticky=W)

# --- Control manual servo ---
Label(controls_frame, text="Ángulo servo (0-180°):").grid(row=14,column=0, sticky=W, pady=(8,0))
anguloVar = IntVar(value=0)
Entry(controls_frame, textvariable=anguloVar, width=6).grid(row=15,column=0, sticky=W)

def enviar_angulo():
    """
    Envía comando 2:<angulo> al Arduino para mover servo a ángulo manual.
    Arduino debe detener el barrido cuando reciba este comando.
    """
    try:
        ang = int(anguloVar.get())
        if 0 <= ang <= 180:
            mySerial.write(f"2:{ang}\n".encode())
            print("Enviado ángulo:", ang)
        else:
            messagebox.showerror("Error", "Ángulo debe estar entre 0 y 180")
    except Exception:
        messagebox.showerror("Error", "Ángulo inválido")

Button(controls_frame, text="Enviar ángulo", command=enviar_angulo, width=18, bg='cyan').grid(row=16,column=0,pady=(4,6))

# --- Botones para controlar barrido automático (6:1 / 6:0) ---
def activar_barrido():
    try: mySerial.write(b"6:1\n")
    except: pass

def desactivar_barrido():
    try: mySerial.write(b"6:0\n")
    except: pass

Button(controls_frame, text="Activar Barrido", command=activar_barrido, width=18, bg='green').grid(row=17,column=0,pady=3)
Button(controls_frame, text="Detener Barrido", command=desactivar_barrido, width=18, bg='red').grid(row=18,column=0,pady=3)

# --- Indicador de estado de alarma por medias ---
Label(controls_frame, text="Estado alarma (medias):").grid(row=23, column=0, sticky=W, pady=(8,0))
alarma_media_label = Label(controls_frame, text="Normal", bg="lightgreen", width=18)
alarma_media_label.grid(row=24, column=0, pady=(2,8))

# --- Botones iniciar/parar/reanudar/reset ---
def IniciarClick():
    """
    Activa el ciclo de lectura y envía el comando 'Iniciar' al Arduino
    para que empiece a transmitir datos.
    """
    global lectura_activa
    lectura_activa = True
    try: mySerial.write(b'Iniciar\n')
    except: pass
    ciclo_lectura()

def PararClick():
    """Detiene el ciclo de lectura y solicita al Arduino parar la transmisión."""
    global lectura_activa
    lectura_activa = False
    try: mySerial.write(b'Parar\n')
    except: pass

def ReanudarClick():
    """Reanuda la lectura y envía 'Iniciar' al Arduino."""
    global lectura_activa
    lectura_activa = True
    try: mySerial.write(b'Iniciar\n')
    except: pass
    ciclo_lectura()

def ResetClick():
    """
    Resetea todos los buffers de datos locales y reactiva el barrido en el satélite.
    También reinicia estados de alerta y fuerza un redraw completo.
    """
    global temperaturas, humedades, eje_x, media_movil, i, radar_angulos, radar_distancias, alerta_activa, alerta_media_activa
    temperaturas=[]; humedades=[]; eje_x=[]; media_movil=[]; i=0
    radar_angulos=[]; radar_distancias=[]
    alerta_activa = False
    alerta_media_activa = False
    alarma_media_label.config(text="Normal", bg="lightgreen")
    try: mySerial.write(b'6:1\n')  # reactivar barrido en Arduino
    except: pass
    actualizar_graficas(force=True)

Button(controls_frame, text="Iniciar", bg='green', fg='white', command=IniciarClick, width=18).grid(row=19,column=0,pady=(8,2))
Button(controls_frame, text="Parar", bg='red', fg='white', command=PararClick, width=18).grid(row=20,column=0,pady=2)
Button(controls_frame, text="Reanudar", bg='yellow', fg='black', command=ReanudarClick, width=18).grid(row=21,column=0,pady=2)
Button(controls_frame, text="Reset (reactiva barrido)", bg='gray', fg='white', command=ResetClick, width=18).grid(row=22,column=0,pady=(6,2))

# =================== Funciones de graficado ===================
def actualizar_graficas(force=False):
    """
    Redibuja las gráficas.
    - Si force==True: redibuja todo.
    - Si force==False: redibuja radar siempre y las líneas con los datos actuales.
    Observación: las líneas son continuas (sin markers), colores preservados.
    """
    # Actualizar líneas (temperatura/humedad)
    line_temp.set_data(eje_x, temperaturas)
    line_hum.set_data(eje_x, humedades)
    # Ajustar media_plot para que coincida en longitud con eje_x
    media_plot = [m if (m is not None and not (isinstance(m, float) and math.isnan(m))) else 0 for m in media_movil]
    line_avg.set_data(eje_x[:len(media_plot)], media_plot)

    # Recalcular límites y escalado automático de ejes para que se ajusten a los nuevos datos
    ax1.relim(); ax1.autoscale_view()
    ax2.relim(); ax2.autoscale_view()
    ax3.relim(); ax3.autoscale_view()

    # Radar: limpiamos y redibujamos con fondo negro y elementos verdes
    ax_radar.clear()
    ax_radar.set_facecolor("black")
    ax_radar.set_theta_zero_location('N')
    ax_radar.set_theta_direction(-1)
    ax_radar.set_rlim(0, 400)
    ax_radar.set_thetamin(0)
    ax_radar.set_thetamax(180)
    ax_radar.set_title("Radar ultrasónico", color='lime')

    if radar_angulos:
        # convertir ángulos a radianes para polar plotting
        theta = [math.radians(a) for a in radar_angulos]
        r = radar_distancias
        # si hay varios puntos, unirlos con una línea fina
        if len(theta) > 1:
            ax_radar.plot(theta, r, color='lime', linewidth=1.2, zorder=2)
        # último punto (más reciente) se dibuja más grande para destacar
        ax_radar.scatter([theta[-1]], [r[-1]], c='lime', s=100, zorder=4, edgecolors='k')

    # Llamamos draw_idle para actualizar la figura embebida sin bloquear GUI
    canvas.draw_idle()

# =================== Lectura serie ===================
def leer_serial():
    """
    Lee todas las líneas disponibles del puerto serie.
    - Radar (2:ang:dist) se procesa siempre y se agrega a radar_angulos/radar_distancias.
    - DHT (1:temp:hum[:A:avg]) se ACEPTA y almacena solo si ha pasado el intervalo DHT configurado,
      para evitar saturar la GUI y la radio LoRa.
    """
    global i, alerta_activa, alerta_media_activa, last_angle_received, last_dht_accepted_ms

    try:
        # Mientras haya bytes esperando en el buffer del puerto serie...
        while mySerial.in_waiting > 0:
            raw = mySerial.readline().decode('utf-8', errors='ignore').strip()
            if not raw:
                continue  # saltar líneas vacías
            #print("Serie <-", raw)  # útil para depuración
            trozos = raw.split(':')
            now_ms = int(time.time()*1000)

            # --- DHT: 1:<temp>:<hum>[:A:<avg>] ---
            if len(trozos) >= 3 and trozos[0] == '1':
                # Decidir si aceptamos esta lectura según el intervalo configurado por el usuario
                try:
                    intervalo_ms = max(0, int(intervaloDHTVar.get())) * 1000
                except Exception:
                    intervalo_ms = 3000  # fallback seguro
                # Si intervalo_ms == 0 aceptamos todas las lecturas; de lo contrario respetamos el intervalo
                accept = False
                if intervalo_ms == 0:
                    accept = True
                else:
                    if now_ms - last_dht_accepted_ms >= intervalo_ms:
                        accept = True

                if not accept:
                    # descartamos esta lectura (para no saturar la GUI / LoRa)
                    # Nota: podrías contar lecturas descartadas si te interesa el logging.
                    continue

                # Aceptamos la lectura y actualizamos la marca temporal
                last_dht_accepted_ms = now_ms
                try:
                    temperatura = float(trozos[1])
                    hum = float(trozos[2])
                except Exception:
                    # valores inválidos: saltar
                    continue

                # Append a las listas y actualizar contador
                eje_x.append(i)
                temperaturas.append(temperatura)
                humedades.append(hum)
                i += 1

                # manejar media según modo (si Arduino envía A:<avg> se usa esa media)
                N = max(1, int(ventanaVar.get()))
                if modoVar.get() == "arduino" and len(trozos) >= 5 and trozos[3] == 'A':
                    try:
                        avg = float(trozos[4])
                        media_movil.append(avg)
                    except Exception:
                        # fallback: calcular media local
                        if len(temperaturas) >= N:
                            media_movil.append(sum(temperaturas[-N:]) / N)
                        else:
                            media_movil.append(float('nan'))
                else:
                    # modo Python o Arduino sin avg: calcular localmente
                    if len(temperaturas) >= N:
                        media_movil.append(sum(temperaturas[-N:]) / N)
                    else:
                        media_movil.append(float('nan'))

                # --- Alerta: 3 últimas TEMPERATURAS individuales > límite ---
                if len(temperaturas) >= 3:
                    ult3 = temperaturas[-3:]
                    try:
                        limite = float(limiteVar.get())
                    except Exception:
                        limite = limite_temp
                    if all(x > limite for x in ult3) and not alerta_activa:
                        alerta_activa = True
                        # Mostrar diálogo emergente (bloqueante)
                        messagebox.showwarning("Alerta", f"Las 3 últimas temperaturas superan {limite} °C")
                    elif not all(x > limite for x in ult3) and alerta_activa:
                        alerta_activa = False

                # --- Alerta NUEVA: 3 últimas MEDIAS > límite ---
                medias_validas = [m for m in media_movil if (m is not None and not (isinstance(m, float) and math.isnan(m)))]
                if len(medias_validas) >= 3:
                    last3_medias = medias_validas[-3:]
                    try:
                        limite = float(limiteVar.get())
                    except Exception:
                        limite = limite_temp
                    if all(m > limite for m in last3_medias):
                        if not alerta_media_activa:
                            alerta_media_activa = True
                            alarma_media_label.config(text="Peligro", bg="red")
                            messagebox.showwarning("Alerta MEDIA", f"Las 3 últimas MEDIAS superan {limite} °C")
                    else:
                        if alerta_media_activa:
                            alerta_media_activa = False
                            alarma_media_label.config(text="Normal", bg="lightgreen")

            # --- Radar ultrasónico: 2:<angulo>:<distancia> ---
            elif len(trozos) >= 3 and trozos[0] == '2':
                try:
                    ang = float(trozos[1])
                    dist = float(trozos[2])
                    last_angle_received = ang
                except Exception:
                    continue
                # Validar rango de ángulo (0..180)
                if ang < 0 or ang > 180:
                    continue
                # Almacenar en buffers del radar y mantener solo los últimos RADAR_MAX_POINTS
                radar_angulos.append(ang)
                radar_distancias.append(dist)
                while len(radar_angulos) > RADAR_MAX_POINTS:
                    radar_angulos.pop(0)
                    radar_distancias.pop(0)

            else:
                # Otros códigos (fallos y mensajes informativos) para depuración
                if trozos[0] == '3':
                    print("Satélite: fallo DHT")
                elif trozos[0] == '5':
                    print("Satélite msg:", ":".join(trozos[1:]))
                elif trozos[0] == '6':
                    print("Satélite: fallo sensor distancia")
                else:
                    print("Otro mensaje:", raw)

    except serial.SerialException as e:
        # Manejo básico de excepción del puerto serie (ej. desconexión)
        print("Error puerto serie:", e)

# =================== Ciclo lectura principal ===================
def ciclo_lectura():
    """
    Ciclo principal que:
     - lee el buffer del puerto serie con frecuencia para vaciarlo (evita saturación).
     - acepta lecturas DHT solo cuando haya pasado el intervalo configurado (evita que la GUI se actualice cada paquete).
     - actualiza las gráficas (radar siempre; líneas cuando haya datos nuevos DHT aceptados).
    """
    if lectura_activa:
        # Vaciar buffer y procesar entradas
        leer_serial()
        # Siempre redibujar radar + líneas con datos actuales (las líneas se actualizan si se aceptó DHT)
        actualizar_graficas()
        # Programar siguiente lectura rápida (100ms) para mantener buffer vacío y radar responsivo
        window.after(100, ciclo_lectura)

# =================== Cierre ===================
def on_close():
    """Callback para cierre de ventana: cierra puerto serie y destruye GUI."""
    global lectura_activa
    lectura_activa = False
    try: mySerial.close()
    except: pass
    window.destroy()

# Asociamos el callback y arrancamos el loop de Tkinter
window.protocol("WM_DELETE_WINDOW", on_close)
window.mainloop()











INTERFAZ CON ORBITA NUEVO
# =================== CODIGO COMPLETO CON ORBITA FUNCIONAL ===================

import serial
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from tkinter import *
from tkinter import messagebox
import math
import time
import re

# =================== Configuración puerto ===================
device = 'COM5'  # Cambia al puerto correcto
mySerial = serial.Serial(device, 9600, timeout=1)

# =================== Variables de datos ===================
temperaturas = []
humedades = []
eje_x = []
media_movil = []

alerta_activa = False
alerta_media_activa = False
limite_temp = 30.0
ventana_default = 10
i = 0
lectura_activa = False

radar_angulos = []
radar_distancias = []
RADAR_MAX_POINTS = 3
last_angle_received = None
modo_media = "python"

last_dht_accepted_ms = 0

# =================== Variables órbita ===================
x_orbit = []
y_orbit = []
regex_orbit = re.compile(r"Position: \(X: ([\d\.-]+) m, Y: ([\d\.-]+) m, Z: ([\d\.-]+) m\)")
R_EARTH = 6371000  # Radio de la Tierra

# =================== Ventana principal ===================
window = Tk()
window.title("Ground Station - Radar + Gráficas + Órbita")
window.geometry("1600x900")

# =================== Figuras ===================
fig = plt.figure(figsize=(12, 9))
ax1 = fig.add_subplot(3, 3, 1)                   # temperatura
ax2 = fig.add_subplot(3, 3, 4)                   # humedad
ax3 = fig.add_subplot(3, 3, 7)                   # media móvil
ax_radar = fig.add_subplot(1, 3, 3, polar=True)  # radar polar
ax_orbit = fig.add_subplot(3, 3, 2)              # órbita

# --- Inicializar líneas ---
line_temp, = ax1.plot([], [], linestyle='-', marker=None, color='red', label="Temperatura")
ax1.set_title("Temperatura (°C)")
ax1.grid(True)
ax1.legend()

line_hum, = ax2.plot([], [], linestyle='-', marker=None, color='blue', label="Humedad")
ax2.set_title("Humedad (%)")
ax2.grid(True)
ax2.legend()

line_avg, = ax3.plot([], [], linestyle='-', marker=None, color='green', label="Media móvil")
ax3.set_title("Media móvil")
ax3.grid(True)
ax3.legend()

# --- Radar ---
ax_radar.set_facecolor("black")
ax_radar.set_theta_zero_location('N')
ax_radar.set_theta_direction(-1)
ax_radar.set_rlim(0, 400)
ax_radar.set_thetamin(0)
ax_radar.set_thetamax(180)
ax_radar.set_title("Radar ultrasónico", color='lime')

# --- Órbita ---
orbit_line, = ax_orbit.plot([], [], 'bo-', markersize=2, label='Órbita Satélite')
last_point_plot = ax_orbit.scatter([], [], color='red', s=50, label='Último Punto', zorder=5)
earth_circle = plt.Circle((0, 0), R_EARTH, color='orange', fill=False, label='Tierra')
ax_orbit.add_artist(earth_circle)
ax_orbit.set_xlim(-7e6, 7e6)
ax_orbit.set_ylim(-7e6, 7e6)
ax_orbit.set_aspect('equal', 'box')
ax_orbit.set_xlabel('X (m)')
ax_orbit.set_ylabel('Y (m)')
ax_orbit.set_title('Órbita Equatorial (Vista Polo Norte)')
ax_orbit.grid(True)
ax_orbit.legend()

# --- Integración Matplotlib en Tkinter ---
canvas = FigureCanvasTkAgg(fig, master=window)
canvas.draw()
canvas.get_tk_widget().grid(row=0, column=0, rowspan=20, padx=10, pady=10)

# =================== Panel de controles ===================
controls_frame = Frame(window)
controls_frame.grid(row=0, column=1, sticky=N, padx=12)

Label(controls_frame, text="Ground Station v2.4", font=("Courier", 18, "italic")).grid(row=0, column=0, pady=(0,10))
Label(controls_frame, text="Límite temperatura (°C):").grid(row=1, column=0, sticky=W)
limiteVar = StringVar(value=str(limite_temp))
Entry(controls_frame, textvariable=limiteVar, width=10).grid(row=2,column=0, sticky=W)

Label(controls_frame, text="Ventana media móvil (N):").grid(row=3,column=0, sticky=W)
ventanaVar = IntVar(value=ventana_default)
Spinbox(controls_frame, from_=1, to=200, textvariable=ventanaVar, width=6).grid(row=4,column=0, sticky=W)

Label(controls_frame, text="Intervalo envío DHT (s):").grid(row=5,column=0, sticky=W, pady=(6,0))
intervaloDHTVar = IntVar(value=3)
Spinbox(controls_frame, from_=1, to=3600, textvariable=intervaloDHTVar, width=6).grid(row=6,column=0, sticky=W)

def send_intervalo_dht():
    try:
        s = int(intervaloDHTVar.get())
        mySerial.write(f"1:{s}\n".encode())
    except:
        messagebox.showerror("Error", "Intervalo DHT inválido")
Button(controls_frame, text="Enviar intervalo DHT", command=send_intervalo_dht, width=18).grid(row=7,column=0,pady=(4,8))

Label(controls_frame, text="Intervalo ultrasonidos (ms):").grid(row=8,column=0, sticky=W)
intervaloUltraVar = IntVar(value=500)
Spinbox(controls_frame, from_=50, to=10000, textvariable=intervaloUltraVar, width=8).grid(row=9,column=0, sticky=W)
def send_intervalo_ultra():
    try:
        ms = int(intervaloUltraVar.get())
        mySerial.write(f"7:{ms}\n".encode())
    except:
        messagebox.showerror("Error", "Intervalo ultrasonidos inválido")
Button(controls_frame, text="Enviar intervalo ultrasonidos", command=send_intervalo_ultra, width=18).grid(row=10,column=0,pady=(4,8))

Label(controls_frame, text="Dónde calcular la media:").grid(row=11,column=0, sticky=W)
modoVar = StringVar(value="python")
def modo_media_changed():
    global modo_media
    modo_media = modoVar.get()
    if modo_media == "arduino":
        mySerial.write(b"8:1\n")
        time.sleep(0.05)
        n = int(ventanaVar.get())
        mySerial.write(f"9:{n}\n".encode())
    else:
        mySerial.write(b"8:0\n")
Radiobutton(controls_frame, text="Python (local)", variable=modoVar, value="python", command=modo_media_changed).grid(row=12,column=0, sticky=W)
Radiobutton(controls_frame, text="Arduino (remoto)", variable=modoVar, value="arduino", command=modo_media_changed).grid(row=13,column=0, sticky=W)

Label(controls_frame, text="Ángulo servo (0-180°):").grid(row=14,column=0, sticky=W, pady=(8,0))
anguloVar = IntVar(value=0)
Entry(controls_frame, textvariable=anguloVar, width=6).grid(row=15,column=0, sticky=W)
def enviar_angulo():
    try:
        ang = int(anguloVar.get())
        if 0 <= ang <= 180:
            mySerial.write(f"2:{ang}\n".encode())
        else:
            messagebox.showerror("Error", "Ángulo debe estar entre 0 y 180")
    except:
        messagebox.showerror("Error", "Ángulo inválido")
Button(controls_frame, text="Enviar ángulo", command=enviar_angulo, width=18, bg='cyan').grid(row=16,column=0,pady=(4,6))

Button(controls_frame, text="Activar Barrido", command=lambda: mySerial.write(b"6:1\n"), width=18, bg='green').grid(row=17,column=0,pady=3)
Button(controls_frame, text="Detener Barrido", command=lambda: mySerial.write(b"6:0\n"), width=18, bg='red').grid(row=18,column=0,pady=3)

Label(controls_frame, text="Estado alarma (medias):").grid(row=23, column=0, sticky=W, pady=(8,0))
alarma_media_label = Label(controls_frame, text="Normal", bg="lightgreen", width=18)
alarma_media_label.grid(row=24, column=0, pady=(2,8))

# =================== Funciones graficado ===================
def actualizar_graficas(force=False):
    # DHT
    line_temp.set_data(eje_x, temperaturas)
    line_hum.set_data(eje_x, humedades)
    media_plot = [m if (m is not None and not (isinstance(m, float) and math.isnan(m))) else 0 for m in media_movil]
    line_avg.set_data(eje_x[:len(media_plot)], media_plot)
    ax1.relim(); ax1.autoscale_view()
    ax2.relim(); ax2.autoscale_view()
    ax3.relim(); ax3.autoscale_view()

    # Radar
    ax_radar.clear()
    ax_radar.set_facecolor("black")
    ax_radar.set_theta_zero_location('N')
    ax_radar.set_theta_direction(-1)
    ax_radar.set_rlim(0, 400)
    ax_radar.set_thetamin(0)
    ax_radar.set_thetamax(180)
    ax_radar.set_title("Radar ultrasónico", color='lime')
    if radar_angulos:
        theta = [math.radians(a) for a in radar_angulos]
        r = radar_distancias
        if len(theta) > 1:
            ax_radar.plot(theta, r, color='lime', linewidth=1.2)
        ax_radar.scatter([theta[-1]], [r[-1]], c='lime', s=100, edgecolors='k')

    # Órbita
    orbit_line.set_data(x_orbit, y_orbit)
    if x_orbit and y_orbit:
        global last_point_plot
        last_point_plot.remove()
        last_point_plot = ax_orbit.scatter([x_orbit[-1]], [y_orbit[-1]], color='red', s=50, zorder=5)

    ax_orbit.relim()
    ax_orbit.autoscale_view()
    canvas.draw_idle()

# =================== Lectura serie ===================
def leer_serial():
    global i, alerta_activa, alerta_media_activa, last_angle_received, last_dht_accepted_ms

    try:
        while mySerial.in_waiting > 0:
            raw = mySerial.readline().decode('utf-8', errors='ignore').strip()
            if not raw: continue

            # --- DHT ---
            trozos = raw.split(':')
            now_ms = int(time.time()*1000)
            if len(trozos) >= 3 and trozos[0] == '1':
                intervalo_ms = max(0, int(intervaloDHTVar.get())) * 1000
                if intervalo_ms == 0 or now_ms - last_dht_accepted_ms >= intervalo_ms:
                    last_dht_accepted_ms = now_ms
                    try:
                        temperatura = float(trozos[1])
                        hum = float(trozos[2])
                    except:
                        continue
                    eje_x.append(i)
                    temperaturas.append(temperatura)
                    humedades.append(hum)
                    i += 1

                    # Media
                    N = max(1, int(ventanaVar.get()))
                    if modoVar.get() == "arduino" and len(trozos) >= 5 and trozos[3] == 'A':
                        try: media_movil.append(float(trozos[4]))
                        except: media_movil.append(sum(temperaturas[-N:])/N if len(temperaturas)>=N else float('nan'))
                    else:
                        media_movil.append(sum(temperaturas[-N:])/N if len(temperaturas)>=N else float('nan'))

                    # Alertas
                    if len(temperaturas)>=3 and all(x>float(limiteVar.get()) for x in temperaturas[-3:]) and not alerta_activa:
                        alerta_activa=True; messagebox.showwarning("Alerta", f"Últimas 3 temperaturas superan {limiteVar.get()} °C")
                    elif alerta_activa and len(temperaturas)>=3 and not all(x>float(limiteVar.get()) for x in temperaturas[-3:]):
                        alerta_activa=False

                    medias_validas = [m for m in media_movil if not (isinstance(m,float) and math.isnan(m))]
                    if len(medias_validas)>=3 and all(m>float(limiteVar.get()) for m in medias_validas[-3:]):
                        alerta_media_activa=True; alarma_media_label.config(text="Peligro", bg="red")
                    else:
                        alerta_media_activa=False; alarma_media_label.config(text="Normal", bg="lightgreen")

            # --- Radar ---
            elif len(trozos)>=3 and trozos[0]=='2':
                try: ang = float(trozos[1]); dist=float(trozos[2]); last_angle_received=ang
                except: continue
                if 0<=ang<=180:
                    radar_angulos.append(ang)
                    radar_distancias.append(dist)
                    while len(radar_angulos)>RADAR_MAX_POINTS:
                        radar_angulos.pop(0); radar_distancias.pop(0)

            # --- Órbita ---
            match = regex_orbit.search(raw)
            if match:
                x_orbit.append(float(match.group(1)))
                y_orbit.append(float(match.group(2)))

            # Otros mensajes
            elif trozos[0]=='3': print("Satélite: fallo DHT")
            elif trozos[0]=='5': print("Satélite msg:", ":".join(trozos[1:]))
            elif trozos[0]=='6': print("Satélite: fallo sensor distancia")
            else: print("Otro mensaje:", raw)

    except serial.SerialException as e:
        print("Error puerto serie:", e)

# =================== Ciclo lectura ===================
def ciclo_lectura():
    if lectura_activa:
        leer_serial()
        actualizar_graficas()
        window.after(100, ciclo_lectura)

# =================== Controles iniciar/parar ===================
def IniciarClick():
    global lectura_activa
    lectura_activa=True
    try: mySerial.write(b'Iniciar\n')
    except: pass
    ciclo_lectura()
def PararClick():
    global lectura_activa
    lectura_activa=False
    try: mySerial.write(b'Parar\n')
    except: pass
def ReanudarClick():
    global lectura_activa
    lectura_activa=True
    try: mySerial.write(b'Iniciar\n')
    except: pass
    ciclo_lectura()
def ResetClick():
    global temperaturas, humedades, eje_x, media_movil, i, radar_angulos, radar_distancias, alerta_activa, alerta_media_activa, x_orbit, y_orbit
    temperaturas=[]; humedades=[]; eje_x=[]; media_movil=[]; i=0
    radar_angulos=[]; radar_distancias=[]
    x_orbit=[]; y_orbit=[]
    alerta_activa=False; alerta_media_activa=False
    alarma_media_label.config(text="Normal", bg="lightgreen")
    try: mySerial.write(b'6:1\n')
    except: pass
    actualizar_graficas(force=True)

Button(controls_frame, text="Iniciar", bg='green', fg='white', command=IniciarClick, width=18).grid(row=19,column=0,pady=(8,2))
Button(controls_frame, text="Parar", bg='red', fg='white', command=PararClick, width=18).grid(row=20,column=0,pady=2)
Button(controls_frame, text="Reanudar", bg='yellow', fg='black', command=ReanudarClick, width=18).grid(row=21,column=0,pady=2)
Button(controls_frame, text="Reset (reactiva barrido)", bg='gray', fg='white', command=ResetClick, width=18).grid(row=22,column=0,pady=(6,2))

# =================== Cierre ===================
def on_close():
    global lectura_activa
    lectura_activa=False
    try: mySerial.close()
    except: pass
    window.destroy()
window.protocol("WM_DELETE_WINDOW", on_close)
window.mainloop()





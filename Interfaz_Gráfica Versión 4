import matplotlib
matplotlib.use("TkAgg")
import matplotlib.collections
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure
from mpl_toolkits.mplot3d import Axes3D  # noqa

from tkinter import *
from tkinter import messagebox, Toplevel
import math
import numpy as np
import serial
import time
import re
import datetime
import os

# =================== CONFIG ===================
device = 'COM6'  # Cambia al puerto correcto
MAP_IMAGE_PATH = r"C:\Users\kauav\Desktop\Versión 4\earth_hd.jpg"

FIGSIZE_ORBIT_NORMAL = (6, 3.2)
FIGSIZE_ORBIT_FULL   = (11, 6)

DARK_BG   = "#050816"
CARD_BG   = "#0b1020"
CARD_ALT  = "#0f172a"
TEXT_FG   = "#e5f2ff"
ACCENT    = "#38bdf8"
ACCENT_2  = "#a855f7"
DANGER    = "#f97373"
OK_COLOR  = "#22c55e"

LABEL_FONT = ("Segoe UI", 9)
ENTRY_FONT = ("Segoe UI", 9)
BTN_FONT   = ("Segoe UI", 8, "bold")
BTN_PADY   = 4
BTN_WIDTH  = 14

MAX_LOG_LINES = 400

# =================== SERIE ===================
class DummySerial:
    def write(self, data):
        print("SERIAL SIM:", data.decode(errors="ignore").strip())

    @property
    def in_waiting(self):
        return 0

    def readline(self):
        return b""

    def close(self):
        pass

try:
    mySerial = serial.Serial(device, 9600, timeout=1)
    print(f"Puerto serie {device} abierto correctamente")
except serial.SerialException as e:
    print(f"No se pudo abrir el puerto {device}: {e}")
    print("Usando puerto serie simulado (DummySerial).")
    mySerial = DummySerial()

# =================== VARIABLES GLOBALES ===================
temperaturas = []
humedades = []
eje_x = []
media_movil = []

alerta_activa = False
alerta_media_activa = False
limite_temp = 30.0
ventana_default = 10
i = 0
lectura_activa = False

radar_echoes = []
RADAR_MAX_POINTS = 50
RADAR_MAX_AGE = 10
last_angle_received = None

modo_media = "python"
last_dht_accepted_ms = 0

# Órbita
x_orbit = []
y_orbit = []
z_orbit = []
R_EARTH = 3.5e6
MAX_ORBIT_POINTS = 2000

regex_orbit = re.compile(
    r"Orbit \| Time: [\d\.]+ s \| X: ([\d\.-]+) m, Y: ([\d\.-]+) m, Z: ([\d\.-]+)"
)

# Log
LOG_FILE = "eventos.log"
log_lines = []  # (timestamp, tipo, texto)
log_filter_tipo = "TODOS"

def registrar_evento(tipo, descripcion):
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    linea = f"{timestamp} | {tipo} | {descripcion}"
    try:
        with open(LOG_FILE, "a", encoding="utf-8") as f:
            f.write(linea + "\n")
    except Exception as e:
        print("Error escribiendo log:", e)
    print("EVENTO:", linea)
    log_lines.append((timestamp, tipo, descripcion))
    if len(log_lines) > MAX_LOG_LINES:
        del log_lines[0]

def filtrar_logs_por_tipo():
    if log_filter_tipo == "TODOS":
        return log_lines
    return [l for l in log_lines if l[1] == log_filter_tipo]

def set_axes_equal(ax):
    limits = np.array([ax.get_xlim3d(), ax.get_ylim3d(), ax.get_zlim3d()])
    spans = limits[:, 1] - limits[:, 0]
    centers = np.mean(limits, axis=1)
    radius = 0.5 * max(spans)
    ax.set_xlim3d([centers[0] - radius, centers[0] + radius])
    ax.set_ylim3d([centers[1] - radius, centers[1] + radius])
    ax.set_zlim3d([centers[2] - radius, centers[2] + radius])
    ax.set_box_aspect([1, 1, 1])

# =================== VENTANA PRINCIPAL ===================
window = Tk()
window.title("Ground Station - Radar + Gráficas + Órbita")
window.state("zoomed")
window.configure(bg=DARK_BG)

window.grid_rowconfigure(0, weight=3)
window.grid_rowconfigure(1, weight=2)
window.grid_columnconfigure(0, weight=1)
window.grid_columnconfigure(1, weight=1)

frame_mapa  = Frame(window, bg=CARD_BG, bd=2, relief="ridge",
                    highlightbackground=ACCENT, highlightcolor=ACCENT, highlightthickness=1)
frame_radar = Frame(window, bg=CARD_BG, bd=2, relief="ridge",
                    highlightbackground=ACCENT_2, highlightcolor=ACCENT_2, highlightthickness=1)
frame_graf  = Frame(window, bg=CARD_BG, bd=2, relief="ridge",
                    highlightbackground="#64748b", highlightcolor="#64748b", highlightthickness=1)

frame_mapa.grid(row=0, column=0, columnspan=2, sticky="nsew", padx=10, pady=10)
frame_radar.grid(row=1, column=0, sticky="nsew", padx=10, pady=(0,10))
frame_graf.grid(row=1, column=1, sticky="nsew", padx=(0,10), pady=(0,10))

for f in (frame_mapa, frame_radar, frame_graf):
    f.grid_rowconfigure(0, weight=0)
    f.grid_rowconfigure(1, weight=1)
    f.grid_columnconfigure(0, weight=1)

def add_header(frame, title_text):
    header = Frame(frame, bg=CARD_BG, bd=0, highlightthickness=0)
    header.grid(row=0, column=0, sticky="ew")
    header.grid_columnconfigure(0, weight=1)
    lbl = Label(header, text=title_text, bg=CARD_BG, fg=ACCENT,
                font=("Segoe UI", 10, "bold"))
    lbl.grid(row=0, column=0, sticky="w", padx=8, pady=3)
    return header

# ---------- MAPA / LOG / OBSERVACIONES ----------
map_header = add_header(frame_mapa, "Módulo Órbita / Registro / Observaciones")

def abrir_manual():
    texto = (
        "MANUAL DE USO\n\n"
        "- Iniciar: el satélite comienza a transmitir datos DHT, radar y órbita.\n"
        "- Parar: detiene la transmisión, pero puedes seguir moviendo el servo.\n"
        "- Barrido servo: activa/desactiva el barrido automático del servo en el satélite.\n"
        "- Registro observación: escribe notas manuales en el log.\n"
        "- Filtro: muestra solo ALERTA, OBSERVACION, INFO, COMANDOS o ERRORES.\n"
    )
    top = Toplevel(window)
    top.title("Manual de la Ground Station")
    top.configure(bg=CARD_BG)
    top.geometry("600x500")
    top.grid_rowconfigure(0, weight=1)
    top.grid_columnconfigure(0, weight=1)

    txt = Text(top, bg="#020617", fg=TEXT_FG, wrap="word",
               font=("Segoe UI", 9))
    txt.grid(row=0, column=0, sticky="nsew", padx=8, pady=8)
    txt.insert("1.0", texto)
    txt.config(state="disabled")

    btn_cerrar = Button(top, text="Cerrar", command=top.destroy,
                        bg=ACCENT, fg="#020617", relief="flat",
                        font=BTN_FONT, width=10)
    btn_cerrar.grid(row=1, column=0, pady=6)

map_header.grid_columnconfigure(1, weight=0)
map_header.grid_columnconfigure(2, weight=0)
map_header.grid_columnconfigure(3, weight=0)
map_header.grid_columnconfigure(4, weight=0)
map_header.grid_columnconfigure(5, weight=0)

btn_manual = Button(map_header, text="Manual", command=abrir_manual,
                    bg=ACCENT_2, fg="#020617", relief="flat",
                    font=BTN_FONT, width=9)
btn_manual.grid(row=0, column=1, sticky="e", padx=(0, 4))

def abrir_simulacion_orbital():
    sim = Toplevel(window)
    sim.title("Simulación Orbital (Datos reales)")
    sim.configure(bg="SystemButtonFace")
    sim.state("zoomed")

    sim.grid_rowconfigure(0, weight=0)
    sim.grid_rowconfigure(1, weight=1)
    sim.grid_rowconfigure(2, weight=1)
    sim.grid_columnconfigure(0, weight=1)

    header = Frame(sim)
    header.grid(row=0, column=0, sticky="ew")
    header.grid_columnconfigure(0, weight=1)
    Label(header, text="Simulación orbital 3D / Ground‑track (datos del satélite)",
          font=("Segoe UI", 10, "bold")).grid(
        row=0, column=0, sticky="w", padx=8, pady=3
    )

    orbit_mode = StringVar(value="3d")

    def cerrar_sim():
        sim.destroy()

    def toggle_orbit_mode():
        orbit_mode.set("map" if orbit_mode.get() == "3d" else "3d")
        show_orbit_mode()

    btn_toggle = Button(header, text="Vista 3D / Mapa",
                        command=toggle_orbit_mode,
                        font=("Segoe UI", 8))
    btn_toggle.grid(row=0, column=1, sticky="e", padx=4)

    btn_exit = Button(header, text="Salir",
                      command=cerrar_sim,
                      font=("Segoe UI", 8))
    btn_exit.grid(row=0, column=2, sticky="e", padx=4)

    main_frame = Frame(sim)
    main_frame.grid(row=1, column=0, sticky="nsew", padx=8, pady=8)
    main_frame.grid_rowconfigure(0, weight=1)
    main_frame.grid_columnconfigure(0, weight=1)

    container = Frame(main_frame)
    container.grid(row=0, column=0, sticky="nsew")
    container.grid_rowconfigure(0, weight=1)
    container.grid_columnconfigure(0, weight=1)

    frame_orbit3d = Frame(container)
    frame_orbitmap = Frame(container)

    log_frame_sim = Frame(sim, bg="#e5e7eb")
    log_frame_sim.grid(row=2, column=0, sticky="nsew", padx=8, pady=(0, 8))
    log_frame_sim.grid_rowconfigure(1, weight=1)
    log_frame_sim.grid_columnconfigure(0, weight=1)
    Label(log_frame_sim, text="Registro de eventos (simulación)",
          bg="#e5e7eb", font=("Segoe UI", 9, "bold")).grid(
        row=0, column=0, sticky="w", padx=4, pady=(2, 0)
    )
    txt_log_sim = Text(log_frame_sim, height=6, bg="white", fg="black",
                       font=("Segoe UI", 8))
    txt_log_sim.grid(row=1, column=0, sticky="nsew", padx=4, pady=4)

    def refrescar_log_sim():
        txt_log_sim.delete("1.0", END)
        for ts, tipo, desc in filtrar_logs_por_tipo()[-MAX_LOG_LINES:]:
            txt_log_sim.insert(END, f"{ts} | {tipo} | {desc}\n")
        sim.after(1000, refrescar_log_sim)

    refrescar_log_sim()

    def crear_orbita_3d():
        for w in frame_orbit3d.winfo_children():
            w.destroy()

        fig_local = Figure(figsize=FIGSIZE_ORBIT_FULL, dpi=100)
        ax_local = fig_local.add_subplot(111, projection='3d')

        ax_local.set_title("Órbita Satélite 3D")
        ax_local.set_xlabel("X (m)")
        ax_local.set_ylabel("Y (m)")
        ax_local.set_zlabel("Z (m)")

        R_EARTH_3D = R_EARTH
        u = np.linspace(0, 2 * np.pi, 80)
        v = np.linspace(0, np.pi, 40)
        x_sphere = R_EARTH_3D * np.outer(np.cos(u), np.sin(v))
        y_sphere = R_EARTH_3D * np.outer(np.sin(u), np.sin(v))
        z_sphere = R_EARTH_3D * np.outer(np.ones_like(u), np.cos(v))
        ax_local.plot_surface(x_sphere, y_sphere, z_sphere,
                              cmap="Blues", edgecolor='none', alpha=0.9)

        orbit_line, = ax_local.plot([], [], [], '-', linewidth=2, color="red", label='Órbita')
        satellite_marker, = ax_local.plot([], [], [], 'o', markersize=5, color="green", label='Satélite')
        ax_local.legend(fontsize=8)

        set_axes_equal(ax_local)

        frame_orbit3d.grid_rowconfigure(0, weight=1)
        frame_orbit3d.grid_columnconfigure(0, weight=1)

        canvas_local = FigureCanvasTkAgg(fig_local, master=frame_orbit3d)
        canvas_local.draw()
        canvas_local.get_tk_widget().grid(row=0, column=0, sticky="nsew")

        last_len = {"n": 0}

        def actualizar_local():
            if len(x_orbit) != last_len["n"] and x_orbit and y_orbit and z_orbit:
                last_len["n"] = len(x_orbit)

                xo = np.array(x_orbit)
                yo = np.array(y_orbit)
                zo = np.array(z_orbit)

                orbit_line.set_data(xo, yo)
                orbit_line.set_3d_properties(zo)

                satellite_marker.set_data(xo[-1:], yo[-1:])
                satellite_marker.set_3d_properties(zo[-1:])

                margin = 0.2
                x_min, x_max = xo.min(), xo.max()
                y_min, y_max = yo.min(), yo.max()
                z_min, z_max = zo.min(), zo.max()

                dx = x_max - x_min
                dy = y_max - y_min
                dz = z_max - z_min
                max_range = max(dx, dy, dz) * (1 + margin)
                if max_range == 0:
                    max_range = R_EARTH_3D * 2.0

                cx = (x_max + x_min) / 2.0
                cy = (y_max + y_min) / 2.0
                cz = (z_max + z_min) / 2.0

                ax_local.set_xlim(cx - max_range / 2, cx + max_range / 2)
                ax_local.set_ylim(cy - max_range / 2, cy + max_range / 2)
                ax_local.set_zlim(cz - max_range / 2, cz + max_range / 2)

                set_axes_equal(ax_local)
                canvas_local.draw()

            sim.after(800, actualizar_local)

        actualizar_local()

    def crear_orbita_mapa():
        for w in frame_orbitmap.winfo_children():
            w.destroy()

        fig_map = Figure(figsize=FIGSIZE_ORBIT_FULL, dpi=100)
        ax_map = fig_map.add_subplot(111)

        ax_map.set_title("Ground track (real + forma sinusoidal)")
        ax_map.set_xlabel("Longitud (°)")
        ax_map.set_ylabel("Latitud (°)")

        try:
            img = plt.imread(MAP_IMAGE_PATH)
        except Exception as e:
            registrar_evento("ERRORES", f"No se pudo cargar mapa: {e}")
            img = np.zeros((480, 960, 3), dtype=np.uint8)

        ax_map.imshow(img, extent=[-180, 180, -90, 90],
                      origin='upper', aspect='auto')
        ax_map.set_xlim(-180, 180)
        ax_map.set_ylim(-90, 90)

        track_line, = ax_map.plot([], [], '-', color="red", linewidth=1.5, label="Trayectoria")
        sat_point, = ax_map.plot([], [], 'o', markersize=5, color="green", label="Satélite")

        ax_map.legend(fontsize=8)

        frame_orbitmap.grid_rowconfigure(0, weight=1)
        frame_orbitmap.grid_columnconfigure(0, weight=1)

        canvas_map = FigureCanvasTkAgg(fig_map, master=frame_orbitmap)
        canvas_map.draw()
        canvas_map.get_tk_widget().grid(row=0, column=0, sticky="nsew")

        def xyz_to_latlon_simple(x, y, z):
            r = math.sqrt(x * x + y * y + z * z)
            if r == 0:
                return 0.0, 0.0
            lat = math.degrees(math.asin(z / r))
            lon = math.degrees(math.atan2(y, x))
            lon = (lon + 180.0) % 360.0 - 180.0
            return lat, lon

        k = 2.0 * math.pi / 180.0
        phase = 0.0
        last_len = {"n": 0}

        def actualizar_mapa():
            if len(x_orbit) != last_len["n"] and x_orbit and y_orbit and z_orbit:
                last_len["n"] = len(x_orbit)

                lats_real = []
                lons_real = []
                for X, Y, Z in zip(x_orbit, y_orbit, z_orbit):
                    lat_r, lon_r = xyz_to_latlon_simple(X, Y, Z)
                    lats_real.append(lat_r)
                    lons_real.append(lon_r)

                if lats_real:
                    N = min(500, len(lats_real))
                    lat_slice = lats_real[-N:]
                    amp = max(60.0, min(89.0, max(abs(v) for v in lat_slice)))
                else:
                    amp = 75.0

                lats_forzadas = [amp * math.sin(k * lon_r + phase)
                                 for lon_r in lons_real]

                lons_plot = [lons_real[0]]
                lats_plot = [lats_forzadas[0]]
                for idx in range(1, len(lons_real)):
                    lon_prev = lons_real[idx - 1]
                    lon_cur = lons_real[idx]
                    lat_cur = lats_forzadas[idx]
                    if abs(lon_cur - lon_prev) > 180:
                        lons_plot.append(float('nan'))
                        lats_plot.append(float('nan'))
                    lons_plot.append(lon_cur)
                    lats_plot.append(lat_cur)

                track_line.set_data(lons_plot, lats_plot)

                lon_last = lons_real[-1]
                lat_last = lats_forzadas[-1]
                sat_point.set_data([lon_last], [lat_last])

                canvas_map.draw()

            sim.after(800, actualizar_mapa)

        actualizar_mapa()

    def show_orbit_mode():
        frame_orbit3d.grid_forget()
        frame_orbitmap.grid_forget()
        if orbit_mode.get() == "3d":
            frame_orbit3d.grid(row=0, column=0, sticky="nsew")
        else:
            frame_orbitmap.grid(row=0, column=0, sticky="nsew")

    crear_orbita_3d()
    crear_orbita_mapa()
    show_orbit_mode()

btn_sim = Button(map_header,
                 text="Simulación",
                 bg="#020617", fg=ACCENT, relief="ridge", bd=1,
                 activebackground="#020617", activeforeground=ACCENT,
                 font=BTN_FONT, width=9,
                 command=abrir_simulacion_orbital)
btn_sim.grid(row=0, column=2, sticky="e", padx=(0, 4))

# Observaciones: label nuevo + entry + botón
Label(map_header, text="Observaciones:",
      bg=CARD_BG, fg=TEXT_FG, font=("Segoe UI", 8)).grid(
    row=1, column=0, sticky="w", padx=8, pady=(2, 1)
)
obs_entry = Entry(map_header, width=32,
                  bg="#020617", fg=TEXT_FG, insertbackground=TEXT_FG,
                  relief="flat", font=("Segoe UI", 8))
obs_entry.grid(row=1, column=1, columnspan=2, sticky="w", padx=(0, 4), pady=(2, 4))

def registrar_observacion():
    texto = obs_entry.get().strip()
    if not texto:
        return
    registrar_evento("OBSERVACION", texto)
    obs_entry.delete(0, END)

btn_obs = Button(map_header, text="Registrar",
                 command=registrar_observacion,
                 bg="#4ade80", fg="#020617", relief="flat",
                 font=("Segoe UI", 8, "bold"), width=9)
btn_obs.grid(row=1, column=3, sticky="e", padx=(0, 4), pady=(2, 4))

# Filtro tipo log
Label(map_header, text="Filtro:",
      bg=CARD_BG, fg=TEXT_FG, font=("Segoe UI", 8)).grid(
    row=0, column=3, sticky="e", padx=(8, 2)
)
filtro_var = StringVar(value="TODOS")
filtro_opts = ["TODOS", "ALERTA", "OBSERVACION", "INFO SATELITE", "COMANDOS", "ERRORES"]
om_filtro = OptionMenu(map_header, filtro_var, *filtro_opts)
om_filtro.config(bg="#020617", fg=TEXT_FG, highlightthickness=0,
                 activebackground="#020617", activeforeground=TEXT_FG,
                 font=("Segoe UI", 8))
om_filtro["menu"].config(bg="#020617", fg=TEXT_FG, font=("Segoe UI", 8))
om_filtro.grid(row=0, column=4, sticky="e", padx=(2, 8))

def cambiar_filtro(*args):
    global log_filter_tipo
    log_filter_tipo = filtro_var.get()
    refrescar_log()

filtro_var.trace_add("write", cambiar_filtro)

# Log principal
map_outer = Frame(frame_mapa, bg=CARD_BG)
map_outer.grid(row=1, column=0, sticky="nsew", padx=4, pady=4)
map_outer.grid_rowconfigure(0, weight=1)
map_outer.grid_columnconfigure(0, weight=1)

log_frame = Frame(map_outer, bg=CARD_BG)
log_frame.grid(row=0, column=0, sticky="nsew")
log_frame.grid_rowconfigure(1, weight=1)
log_frame.grid_columnconfigure(0, weight=1)

Label(log_frame, text="Registro de eventos (filtrado)",
      bg=CARD_BG, fg=TEXT_FG, font=("Segoe UI", 9, "bold")).grid(
    row=0, column=0, sticky="w", padx=6, pady=(2, 0)
)
txt_log = Text(log_frame, bg="#020617", fg="#e5e7eb",
               font=("Segoe UI", 8))
txt_log.grid(row=1, column=0, sticky="nsew", padx=6, pady=4)

def refrescar_log():
    txt_log.delete("1.0", END)
    for ts, tipo, desc in filtrar_logs_por_tipo()[-MAX_LOG_LINES:]:
        txt_log.insert(END, f"{ts} | {tipo} | {desc}\n")
    window.after(1000, refrescar_log)

refrescar_log()

# ---------- RADAR (barrido servo) ----------
add_header(frame_radar, "Radar ultrasónico / Servo")

radar_outer = Frame(frame_radar, bg=CARD_BG)
radar_outer.grid(row=1, column=0, sticky="nsew", padx=4, pady=4)
radar_outer.grid_rowconfigure(0, weight=3)
radar_outer.grid_rowconfigure(1, weight=1)
radar_outer.grid_columnconfigure(0, weight=1)

radar_canvas_frame = Frame(radar_outer, bg=CARD_BG)
radar_canvas_frame.grid(row=0, column=0, sticky="nsew")
radar_canvas_frame.grid_rowconfigure(0, weight=1)
radar_canvas_frame.grid_columnconfigure(0, weight=1)

radar_ctrl_frame = Frame(radar_outer, bg=CARD_ALT)
radar_ctrl_frame.grid(row=1, column=0, sticky="ew", pady=(8, 0), padx=4)
for c in range(5):
    radar_ctrl_frame.grid_columnconfigure(c, weight=1)

def abrir_radar():
    for w in radar_canvas_frame.winfo_children():
        w.destroy()

    fig_radar = Figure(figsize=(5.0, 3.0), dpi=100)
    ax_r = fig_radar.add_subplot(111, polar=True)

    fig_radar.patch.set_facecolor("black")
    ax_r.set_facecolor("black")

    ax_r.set_theta_zero_location('N')
    ax_r.set_theta_direction(1)
    ax_r.set_thetamin(-90)
    ax_r.set_thetamax(90)

    ax_r.set_rlim(0, 400)
    ax_r.set_rticks(range(0, 401, 50))
    ax_r.set_yticklabels([str(r) for r in range(0, 401, 50)], color="lime")
    ax_r.yaxis.set_tick_params(labelsize=7, pad=4)
    ang_ticks = np.deg2rad(np.arange(-90, 91, 30))
    ax_r.set_xticks(ang_ticks)
    ax_r.set_xticklabels([f"{deg}°" for deg in range(-90, 91, 30)],
                         color="lime", fontsize=8)

    ax_r.grid(color="green", alpha=0.4)
    ax_r.spines['polar'].set_color("lime")
    ax_r.tick_params(colors="lime")
    ax_r.set_title("Radar ultrasónico", color="lime", pad=12, fontsize=9)

    info_text = ax_r.text(0.5, 0.96, "", transform=ax_r.transAxes,
                          ha="center", va="bottom", color="lime", fontsize=8)

    fig_radar.subplots_adjust(top=0.88, bottom=0.05, left=0.05, right=0.95)

    canvas_r = FigureCanvasTkAgg(fig_radar, master=radar_canvas_frame)
    canvas_r.draw()
    canvas_r.get_tk_widget().grid(row=0, column=0, sticky="nsew")

    beam_line, = ax_r.plot([], [], color="lime", linewidth=2)

    trail_length = 30
    trail_lines = []
    for i_local in range(trail_length):
        alpha = max(0, 0.4 - i_local * 0.012)
        line, = ax_r.plot([], [], color="lime", linewidth=1.0, alpha=alpha)
        trail_lines.append(line)

    echo_scatter = ax_r.scatter([], [], s=30, c="green")

    frame_counter = {"n": 0}

    def actualizar_radar_local():
        frame_counter["n"] += 1

        # El barrido visual siempre activo (solo es animación local)
        angle_deg = -90 + (frame_counter["n"] * 2.0) % 180
        angle = math.radians(angle_deg)
        r = np.linspace(0, 400, 200)
        theta = np.full_like(r, angle)
        beam_line.set_data(theta, r)

        prev_theta, prev_r = beam_line.get_data()
        last_theta, last_r = prev_theta, prev_r
        for line in trail_lines:
            lt, lr = line.get_data()
            line.set_data(last_theta, last_r)
            last_theta, last_r = lt, lr

        if radar_echoes:
            vivos = []
            for eco in radar_echoes:
                eco["age"] += 1
                if eco["age"] <= RADAR_MAX_AGE:
                    vivos.append(eco)
            radar_echoes[:] = vivos

            if radar_echoes:
                t = [math.radians(e["ang"] - 90.0) for e in radar_echoes]
                d = [e["dist"] for e in radar_echoes]
                alphas = [max(0.0, 1.0 - e["age"] / RADAR_MAX_AGE) for e in radar_echoes]
                colors = [[0.0, 1.0, 0.0, a] for a in alphas]
                offsets = np.column_stack([t, d])
                echo_scatter.set_offsets(offsets)
                echo_scatter.set_color(colors)

                ang_last = radar_echoes[-1]["ang"]
                dist_last = radar_echoes[-1]["dist"]
                info_text.set_text(f"Ángulo: {ang_last:.1f}°  Dist: {dist_last:.1f} cm")
            else:
                echo_scatter.set_offsets(np.empty((0, 2)))
                echo_scatter.set_color([])
                info_text.set_text("Sin ecos")
        else:
            echo_scatter.set_offsets(np.empty((0, 2)))
            echo_scatter.set_color([])
            info_text.set_text("Sin ecos")

        canvas_r.draw()
        window.after(60, actualizar_radar_local)

    actualizar_radar_local()

abrir_radar()

Label(radar_ctrl_frame, text="Ángulo servo (0-180°):",
      bg=CARD_ALT, fg=TEXT_FG, font=LABEL_FONT).grid(
    row=0, column=0, sticky="e", pady=2, padx=4
)
anguloVar = IntVar(value=0)
Entry(radar_ctrl_frame, textvariable=anguloVar, width=6,
      bg="#020617", fg=TEXT_FG, insertbackground=TEXT_FG,
      relief="flat", font=ENTRY_FONT).grid(
    row=0, column=1, sticky="w", padx=(4, 4), pady=2
)

def enviar_angulo():
    try:
        ang = int(anguloVar.get())
        if 0 <= ang <= 180:
            mySerial.write(f"2:{ang}\n".encode())
            registrar_evento("COMANDOS", f"Enviar ángulo servo: {ang}°")
        else:
            messagebox.showerror("Error", "Ángulo debe estar entre 0 y 180")
    except:
        messagebox.showerror("Error", "Ángulo inválido")

Label(radar_ctrl_frame, text="Intervalo ultra (ms):",
      bg=CARD_ALT, fg=TEXT_FG, font=LABEL_FONT).grid(
    row=1, column=0, sticky="e", pady=2, padx=4
)
intervaloUltraVar = IntVar(value=300)
Spinbox(radar_ctrl_frame, from_=50, to=10000, textvariable=intervaloUltraVar, width=7,
        bg="#020617", fg=TEXT_FG,
        buttonbackground="#1e293b", relief="flat",
        font=ENTRY_FONT).grid(
    row=1, column=1, sticky="w", padx=(4, 4), pady=2
)

def send_intervalo_ultra():
    try:
        ms = int(intervaloUltraVar.get())
        mySerial.write(f"7:{ms}\n".encode())
    except:
        messagebox.showerror("Error", "Intervalo ultrasonidos inválido")
    registrar_evento("COMANDOS", f"Enviar intervalo ultrasonidos: {intervaloUltraVar.get()}ms")

Button(radar_ctrl_frame, text="Ángulo servo", command=enviar_angulo,
       bg=ACCENT, fg="#020617", relief="flat",
       font=BTN_FONT, width=BTN_WIDTH).grid(
    row=2, column=0, pady=4, padx=2, sticky="w"
)

Button(radar_ctrl_frame, text="Intervalo ultra", command=send_intervalo_ultra,
       bg=ACCENT_2, fg="#020617", relief="flat",
       font=BTN_FONT, width=BTN_WIDTH).grid(
    row=2, column=1, pady=4, padx=2, sticky="w"
)

def detener_barrido_servo():
    # case 6 del satélite: modoBarrido = false si recibe "6:0"
    try:
        mySerial.write(b"6:0\n")
        registrar_evento("COMANDOS", "Detener barrido servo (satélite)")
    except:
        messagebox.showerror("Error", "No se pudo enviar comando de detener barrido")

def reanudar_barrido_servo():
    # case 6 del satélite: modoBarrido = true si recibe "6:1"
    try:
        mySerial.write(b"6:1\n")
        registrar_evento("COMANDOS", "Reanudar barrido servo (satélite)")
    except:
        messagebox.showerror("Error", "No se pudo enviar comando de reanudar barrido")

Button(radar_ctrl_frame, text="Detener barrido servo",
       command=detener_barrido_servo,
       bg="#f97373", fg="#020617", relief="flat",
       font=BTN_FONT, width=BTN_WIDTH+2).grid(
    row=2, column=2, pady=4, padx=2, sticky="w"
)

Button(radar_ctrl_frame, text="Reanudar barrido servo",
       command=reanudar_barrido_servo,
       bg="#16a34a", fg="#020617", relief="flat",
       font=BTN_FONT, width=BTN_WIDTH+2).grid(
    row=2, column=3, pady=4, padx=2, sticky="w"
)

# ---------- GRÁFICAS (controles pequeños, una columna) ----------
graf_header = add_header(frame_graf, "Gráficas / Medias / DHT / Control")

graf_outer = Frame(frame_graf, bg=CARD_BG)
graf_outer.grid(row=1, column=0, sticky="nsew", padx=4, pady=4)
graf_outer.grid_rowconfigure(0, weight=1)
graf_outer.grid_columnconfigure(0, weight=3)
graf_outer.grid_columnconfigure(1, weight=1)

content_graf = Frame(graf_outer, bg=CARD_BG)
content_graf.grid(row=0, column=0, sticky="nsew", padx=2, pady=2)
content_graf.grid_rowconfigure(0, weight=1)
content_graf.grid_columnconfigure(0, weight=1)

fig = Figure(figsize=(5.5, 3.4), dpi=100)
gs = fig.add_gridspec(3, 1, height_ratios=[2.0, 1.0, 1.0])
ax1 = fig.add_subplot(gs[0, 0])
ax2 = fig.add_subplot(gs[1, 0])
ax3 = fig.add_subplot(gs[2, 0])

fig.subplots_adjust(top=0.93, bottom=0.10, left=0.12, right=0.99, hspace=0.75)
fig.patch.set_facecolor(CARD_BG)
for ax in (ax1, ax2, ax3):
    ax.set_facecolor("#020617")
    ax.tick_params(colors=TEXT_FG, labelsize=7)
    ax.title.set_color(ACCENT)
    ax.title.set_fontsize(9)
    for spine in ax.spines.values():
        spine.set_color("#64748b")
    ax.grid(color="#1e293b", alpha=0.7)

line_temp, = ax1.plot([], [], linestyle='-', color="#fb7185", label="Temperatura")
ax1.set_title("Temperatura (°C)", pad=4)

line_hum, = ax2.plot([], [], linestyle='-', color="#38bdf8", label="Humedad")
ax2.set_title("Humedad (%)", pad=4)

line_avg, = ax3.plot([], [], linestyle='-', color="#4ade80", label="Media móvil")
ax3.set_title("Media móvil", pad=4)

canvas = FigureCanvasTkAgg(fig, master=content_graf)
canvas.draw()
canvas.get_tk_widget().grid(row=0, column=0, sticky="nsew")

cont_inner = Frame(graf_outer, bg=CARD_ALT)
cont_inner.grid(row=0, column=1, sticky="nsew", padx=4, pady=(2, 2))
for r in range(15):
    cont_inner.grid_rowconfigure(r, weight=0)
cont_inner.grid_rowconfigure(14, weight=1)
cont_inner.grid_columnconfigure(0, weight=1)

Label(cont_inner, text="Ground Station v3.0",
      bg=CARD_ALT, fg=ACCENT, font=("Segoe UI", 9, "bold")).grid(
    row=0, column=0, sticky="w", pady=(0, 4), padx=4
)

Label(cont_inner, text="Límite temperatura (°C):",
      bg=CARD_ALT, fg=TEXT_FG, font=LABEL_FONT).grid(
    row=1, column=0, sticky="w", pady=1, padx=4
)
limiteVar = StringVar(value=str(limite_temp))
Entry(cont_inner, textvariable=limiteVar, width=10,
      bg="#020617", fg=TEXT_FG, insertbackground=TEXT_FG,
      relief="flat", font=ENTRY_FONT).grid(
    row=2, column=0, sticky="w", padx=(4, 4), pady=1
)

Label(cont_inner, text="Ventana media móvil (N):",
      bg=CARD_ALT, fg=TEXT_FG, font=LABEL_FONT).grid(
    row=3, column=0, sticky="w", pady=1, padx=4
)
ventanaVar = IntVar(value=ventana_default)

def recalcular_media():
    global media_movil
    N = max(1, int(ventanaVar.get()))
    nueva_media = []
    for j in range(len(temperaturas)):
        if j + 1 >= N:
            ventana = temperaturas[j + 1 - N:j + 1]
        else:
            ventana = temperaturas[:j + 1]
        nueva_media.append(sum(ventana) / len(ventana))
    media_movil = nueva_media
    actualizar_graficas(force=True)

Spinbox(cont_inner, from_=1, to=200, textvariable=ventanaVar, width=10,
        bg="#020617", fg=TEXT_FG, buttonbackground="#1e293b",
        relief="flat", font=ENTRY_FONT).grid(
    row=4, column=0, sticky="w", padx=(4, 4), pady=1
)
ventanaVar.trace_add("write", lambda *args: recalcular_media())

Label(cont_inner, text="Intervalo envío DHT (s):",
      bg=CARD_ALT, fg=TEXT_FG, font=LABEL_FONT).grid(
    row=5, column=0, sticky="w", pady=1, padx=4
)
intervaloDHTVar = IntVar(value=3)
Spinbox(cont_inner, from_=1, to=3600, textvariable=intervaloDHTVar, width=10,
        bg="#020617", fg=TEXT_FG, buttonbackground="#1e293b",
        relief="flat", font=ENTRY_FONT).grid(
    row=6, column=0, sticky="w", padx=(4, 4), pady=1
)

def send_intervalo_dht():
    try:
        s = int(intervaloDHTVar.get())
        mySerial.write(f"1:{s}\n".encode())
    except:
        messagebox.showerror("Error", "Intervalo DHT inválido")
    registrar_evento("COMANDOS", f"Enviar intervalo DHT: {intervaloDHTVar.get()}s")

Label(cont_inner, text="Dónde calcular la media:",
      bg=CARD_ALT, fg=TEXT_FG, font=LABEL_FONT).grid(
    row=7, column=0, sticky="w", pady=(6, 1), padx=4
)
modoVar = StringVar(value="python")

def modo_media_changed():
    global modo_media
    modo_media = modoVar.get()
    if modo_media == "arduino":
        try:
            mySerial.write(b"8:1\n")
            time.sleep(0.05)
            n = int(ventanaVar.get())
            mySerial.write(f"9:{n}\n".encode())
        except:
            pass
    else:
        try:
            mySerial.write(b"8:0\n")
        except:
            pass

Radiobutton(cont_inner, text="Python (local)", variable=modoVar, value="python",
            command=modo_media_changed, bg=CARD_ALT, fg=TEXT_FG,
            selectcolor="#020617", font=("Segoe UI", 8)).grid(
    row=8, column=0, sticky="w", pady=(1, 1), padx=4
)
Radiobutton(cont_inner, text="Arduino (remoto)", variable=modoVar, value="arduino",
            command=modo_media_changed, bg=CARD_ALT, fg=TEXT_FG,
            selectcolor="#020617", font=("Segoe UI", 8)).grid(
    row=9, column=0, sticky="w", pady=(1, 4), padx=4
)

Label(cont_inner, text="Estado alarma (medias):",
      bg=CARD_ALT, fg=TEXT_FG, font=LABEL_FONT).grid(
    row=10, column=0, sticky="w", pady=(4, 1), padx=4
)
alarma_media_label = Label(cont_inner, text="NORMAL", bg=OK_COLOR,
                           fg='#020617', width=16, font=("Segoe UI", 9, "bold"))
alarma_media_label.grid(row=11, column=0, sticky="w", padx=(4, 4), pady=(1, 4))

row_btn = 12

def IniciarClick():
    global lectura_activa
    lectura_activa = True
    try:
        mySerial.write(b'Iniciar\n')
    except:
        pass
    ciclo_lectura()

def PararClick():
    global lectura_activa
    lectura_activa = False
    try:
        mySerial.write(b'Parar\n')
    except:
        pass

def ResetClick():
    global temperaturas, humedades, eje_x, media_movil, i
    global radar_echoes, alerta_activa, alerta_media_activa
    global x_orbit, y_orbit, z_orbit
    temperaturas = []
    humedades = []
    eje_x = []
    media_movil = []
    i = 0
    radar_echoes = []
    x_orbit = []
    y_orbit = []
    z_orbit = []
    alerta_activa = False
    alerta_media_activa = False
    alarma_media_label.config(text="Normal", bg=OK_COLOR)
    try:
        mySerial.write(b'6:1\n')
    except:
        pass
    actualizar_graficas(force=True)

Button(cont_inner, text="Iniciar", bg=OK_COLOR, fg='#020617',
       command=IniciarClick, width=BTN_WIDTH, font=BTN_FONT, relief="flat").grid(
    row=row_btn, column=0, pady=BTN_PADY, padx=4, sticky="w"
)
row_btn += 1

Button(cont_inner, text="Parar", bg=DANGER, fg='#020617',
       command=PararClick, width=BTN_WIDTH, font=BTN_FONT, relief="flat").grid(
    row=row_btn, column=0, pady=BTN_PADY, padx=4, sticky="w"
)
row_btn += 1

Button(cont_inner, text="Reset", bg="#facc15", fg='#020617',
       command=ResetClick, width=BTN_WIDTH, font=BTN_FONT, relief="flat").grid(
    row=row_btn, column=0, pady=BTN_PADY, padx=4, sticky="w"
)
row_btn += 1

Button(cont_inner, text="Enviar DHT+Ultra",
       command=lambda: (send_intervalo_dht(), send_intervalo_ultra()),
       bg="#1d4ed8", fg="#e5f2ff", relief="flat",
       font=BTN_FONT, width=BTN_WIDTH).grid(
    row=row_btn, column=0, pady=BTN_PADY, padx=4, sticky="w"
)

# =================== GRÁFICAS Y SERIE ===================
def actualizar_graficas(force=False):
    line_temp.set_data(eje_x, temperaturas)
    line_hum.set_data(eje_x, humedades)

    media_plot = []
    for m in media_movil:
        if m is None or (isinstance(m, float) and math.isnan(m)):
            media_plot.append(0)
        else:
            media_plot.append(m)

    line_avg.set_data(eje_x[:len(media_plot)], media_plot)

    ax1.relim(); ax1.autoscale_view()
    ax2.relim(); ax2.autoscale_view()
    ax3.relim(); ax3.autoscale_view()

    canvas.draw()

def leer_serial():
    global i, alerta_activa, alerta_media_activa, last_angle_received, last_dht_accepted_ms

    try:
        while mySerial.in_waiting > 0:
            raw = mySerial.readline().decode('utf-8', errors='ignore').strip()
            if not raw:
                continue

            if raw.startswith("CHK:"):
                try:
                    partes = raw.split(':')
                    if len(partes) < 3:
                        registrar_evento("ERRORES", "Mensaje corrupto (checksum incompleto)")
                        continue
                    data = ':'.join(partes[1:-1])
                    checksum_recv = int(partes[-1])
                    checksum_calc = sum(bytearray(data, 'utf-8')) % 256
                    if checksum_recv != checksum_calc:
                        registrar_evento("ERRORES", f"Checksum inválido: {raw}")
                        continue
                    raw = data
                except Exception as e:
                    registrar_evento("ERRORES", f"Error leyendo checksum: {raw} ({e})")
                    continue

            trozos = raw.split(':')
            now_ms = int(time.time() * 1000)

            if len(trozos) >= 3 and trozos[0] == '1':
                intervalo_ms = max(0, int(intervaloDHTVar.get())) * 1000
                if intervalo_ms == 0 or now_ms - last_dht_accepted_ms >= intervalo_ms:
                    last_dht_accepted_ms = now_ms
                    try:
                        temperatura = float(trozos[1])
                        hum = float(trozos[2])
                    except:
                        continue
                    eje_x.append(i)
                    temperaturas.append(temperatura)
                    humedades.append(hum)
                    i += 1

                    N = max(1, int(ventanaVar.get()))
                    if modoVar.get() == "arduino" and len(trozos) >= 5 and trozos[3] == 'A':
                        try:
                            media_movil.append(float(trozos[4]))
                        except:
                            media_movil.append(
                                sum(temperaturas[-N:]) / N if len(temperaturas) >= N else float('nan'))
                    else:
                        media_movil.append(
                            sum(temperaturas[-N:]) / N if len(temperaturas) >= N else float('nan'))

                    if len(temperaturas) >= 3 and all(
                            x > float(limiteVar.get()) for x in temperaturas[-3:]) and not alerta_activa:
                        alerta_activa = True
                        messagebox.showwarning("Alerta", f"Últimas 3 temperaturas superan {limiteVar.get()} °C")
                        registrar_evento("ALERTA",
                                         f"Temperatura alta: últimas 3 superan {limiteVar.get()} °C")
                    elif alerta_activa and len(temperaturas) >= 3 and not all(
                            x > float(limiteVar.get()) for x in temperaturas[-3:]):
                        alerta_activa = False

                    medias_validas = [m for m in media_movil if not (isinstance(m, float) and math.isnan(m))]
                    if len(medias_validas) >= 3 and all(
                            m > float(limiteVar.get()) for m in medias_validas[-3:]):
                        alerta_media_activa = True
                        alarma_media_label.config(text="Peligro", bg=DANGER)
                    else:
                        alerta_media_activa = False
                        alarma_media_label.config(text="Normal", bg=OK_COLOR)

            elif len(trozos) >= 3 and trozos[0] == '2':
                try:
                    ang = float(trozos[1])
                    dist = float(trozos[2])
                    last_angle_received = ang

                    if 0 <= ang <= 180:
                        radar_echoes.append({"ang": ang, "dist": dist, "age": 0})
                        if len(radar_echoes) > RADAR_MAX_POINTS:
                            radar_echoes[:] = radar_echoes[-RADAR_MAX_POINTS:]
                    else:
                        registrar_evento("ERRORES", f"Ángulo radar inválido: {ang}")
                except Exception as e:
                    registrar_evento("ERRORES", f"Radar inválido: {raw} ({e})")

            elif trozos[0] == '3':
                registrar_evento("ERRORES", "Satélite: fallo DHT")
            elif trozos[0] == '5':
                registrar_evento("INFO SATELITE", "Satélite msg: " + ":".join(trozos[1:]))
            elif trozos[0] == '6':
                registrar_evento("ERRORES", "Satélite: fallo sensor distancia")
            else:
                registrar_evento("INFO SATELITE", "Otro mensaje: " + raw)

            match = regex_orbit.search(raw)
            if match:
                try:
                    x_orbit.append(float(match.group(1)))
                    y_orbit.append(float(match.group(2)))
                    z_orbit.append(float(match.group(3)))

                    if len(x_orbit) > MAX_ORBIT_POINTS:
                        x_orbit[:] = x_orbit[-MAX_ORBIT_POINTS:]
                        y_orbit[:] = y_orbit[-MAX_ORBIT_POINTS:]
                        z_orbit[:] = z_orbit[-MAX_ORBIT_POINTS:]
                except ValueError:
                    registrar_evento("ERRORES", f"Órbita inválida: {raw}")

    except serial.SerialException as e:
        print("Error puerto serie:", e)
        registrar_evento("ERRORES", f"Error puerto serie: {e}")

def ciclo_lectura():
    if lectura_activa:
        leer_serial()
        actualizar_graficas()
        window.after(120, ciclo_lectura)

def on_close():
    global lectura_activa
    lectura_activa = False
    try:
        mySerial.close()
    except:
        pass
    window.destroy()

window.protocol("WM_DELETE_WINDOW", on_close)
window.mainloop()

import matplotlib
matplotlib.use("TkAgg")
import matplotlib.collections
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure
from mpl_toolkits.mplot3d import Axes3D  # noqa

from tkinter import *
from tkinter import messagebox, Toplevel, BOTH
from tkinter import OptionMenu
from PIL import Image, ImageTk
import math
import random
import numpy as np
import serial
import time
import re
import datetime
import os

# =================== CONFIG ===================
device = 'COM6'  # Cambia al puerto correcto
MAP_IMAGE_PATH = r"C:\Users\iroma\Desktop\computación\python\earth_hd.jpg"

mySerial = serial.Serial(device, 9600, timeout=1)

# =================== Variables de datos ===================
temperaturas = []
humedades = []
eje_x = []
media_movil = []

alerta_activa = False
alerta_media_activa = False
limite_temp = 30.0
ventana_default = 10
i = 0
lectura_activa = False

# ---- Radar: ecos con edad ----
radar_echoes = []
RADAR_MAX_POINTS = 50
RADAR_MAX_AGE = 10
last_angle_received = None

modo_media = "python"
last_dht_accepted_ms = 0

# =================== Variables órbita ===================
x_orbit = []
y_orbit = []
z_orbit = []
R_EARTH = 3.5e6  # radio para esfera 3D
MAX_ORBIT_POINTS = 2000  # límite para mejorar rendimiento

regex_orbit = re.compile(
    r"Orbit \| Time: [\d\.]+ s \| X: ([\d\.-]+) m, Y: ([\d\.-]+) m, Z: ([\d\.-]+)"
)

# =================== Registro de eventos ===================
LOG_FILE = "eventos.log"


def registrar_evento(tipo, descripcion):
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    linea = f"{timestamp} | {tipo} | {descripcion}\n"
    try:
        with open(LOG_FILE, "a", encoding="utf-8") as f:
            f.write(linea)
    except Exception as e:
        print("Error escribiendo log:", e)
    print("EVENTO:", linea.strip())


def recalcular_media():
    global media_movil
    N = max(1, int(ventanaVar.get()))
    nueva_media = []
    for j in range(len(temperaturas)):
        if j + 1 >= N:
            ventana = temperaturas[j + 1 - N:j + 1]
        else:
            ventana = temperaturas[:j + 1]
        nueva_media.append(sum(ventana) / len(ventana))
    media_movil = nueva_media
    actualizar_graficas(force=True)


# =================== Ventana principal / tema oscuro ===================
window = Tk()
window.title("Ground Station - Radar + Gráficas + Órbita")
window.state("zoomed")

DARK_BG = "#202124"
CARD_BG = "#111111"
TEXT_FG = "#f5f5f5"

window.configure(bg=DARK_BG)

window.grid_rowconfigure(0, weight=1)
window.grid_rowconfigure(1, weight=1)
window.grid_columnconfigure(0, weight=1)
window.grid_columnconfigure(1, weight=1)

frame_graficas = Frame(window, bg=CARD_BG, bd=2, relief="ridge")
frame_radar = Frame(window, bg=CARD_BG, bd=2, relief="ridge")
frame_orbita = Frame(window, bg=CARD_BG, bd=2, relief="ridge")
frame_controles = Frame(window, bg="black", bd=2, relief="ridge")

frame_graficas.grid(row=0, column=0, sticky="nsew", padx=8, pady=8)
frame_radar.grid(row=0, column=1, sticky="nsew", padx=8, pady=8)
frame_orbita.grid(row=1, column=0, sticky="nsew", padx=8, pady=8)
frame_controles.grid(row=1, column=1, sticky="nsew", padx=8, pady=8)

for f in (frame_graficas, frame_radar, frame_orbita, frame_controles):
    f.grid_rowconfigure(0, weight=0)
    f.grid_rowconfigure(1, weight=1)
    f.grid_columnconfigure(0, weight=1)

# =================== Pantalla completa ===================
fullscreen_state = {"active": False, "target": None, "saved": {}}


def enter_fullscreen(target_frame):
    if fullscreen_state["active"]:
        return
    fullscreen_state["active"] = True
    fullscreen_state["target"] = target_frame
    for f in (frame_graficas, frame_radar, frame_orbita, frame_controles):
        fullscreen_state["saved"][f] = f.grid_info()
        f.grid_forget()
    target_frame.grid(row=0, column=0, rowspan=2, columnspan=2,
                      sticky="nsew", padx=0, pady=0)


def exit_fullscreen():
    if not fullscreen_state["active"]:
        return
    for f, info in fullscreen_state["saved"].items():
        f.grid(row=info["row"], column=info["column"],
               rowspan=info.get("rowspan", 1),
               columnspan=info.get("columnspan", 1),
               sticky=info.get("sticky", "nsew"),
               padx=8, pady=8)
    fullscreen_state["active"] = False
    fullscreen_state["target"] = None
    fullscreen_state["saved"] = {}


def add_fullscreen_header(frame, title_text):
    header = Frame(frame, bg=CARD_BG, bd=0, highlightthickness=0)
    header.grid(row=0, column=0, sticky="ew")
    header.grid_columnconfigure(0, weight=1)
    lbl = Label(header, text=title_text, bg=CARD_BG, fg=TEXT_FG,
                font=("Segoe UI", 11, "bold"))
    lbl.grid(row=0, column=0, sticky="w", padx=6, pady=4)
    btn_fs = Button(header, text="□", bg="#878282", fg=TEXT_FG, bd=0,
                    command=lambda f=frame: enter_fullscreen(f))
    btn_fs.grid(row=0, column=1, sticky="e", padx=4)
    btn_exit = Button(header, text="-", bg="#878282", fg=TEXT_FG, bd=0,
                      command=exit_fullscreen)
    btn_exit.grid(row=0, column=2, sticky="e", padx=4)


# =================== 1) Gráficas ===================
add_fullscreen_header(frame_graficas, "Gráficas de temperatura / humedad")

content_graf = Frame(frame_graficas, bg=CARD_BG)
content_graf.grid(row=1, column=0, sticky="nsew", padx=4, pady=4)
content_graf.grid_rowconfigure(0, weight=1)
content_graf.grid_columnconfigure(0, weight=1)


fig = Figure(figsize=(4.8, 3.8), dpi=100)
gs = fig.add_gridspec(3, 1, height_ratios=[2.5, 1, 1])
ax1 = fig.add_subplot(gs[0, 0])
ax2 = fig.add_subplot(gs[1, 0])
ax3 = fig.add_subplot(gs[2, 0])

# Añadir esta línea:
fig.subplots_adjust(hspace=0.5)  # prueba valores entre 0.4 y 0.7


fig.patch.set_facecolor(CARD_BG)
for ax in (ax1, ax2, ax3):
    ax.set_facecolor("#222222")
    ax.tick_params(colors=TEXT_FG)
    ax.title.set_color(TEXT_FG)
    for spine in ax.spines.values():
        spine.set_color(TEXT_FG)
    ax.grid(color="#444444", alpha=0.6)

line_temp, = ax1.plot([], [], linestyle='-', color='#ff6b6b', label="Temperatura")
ax1.set_title("Temperatura (°C)", pad=10)

line_hum, = ax2.plot([], [], linestyle='-', color='#4dabf7', label="Humedad")
ax2.set_title("Humedad (%)", pad=10)

line_avg, = ax3.plot([], [], linestyle='-', color='#51cf66', label="Media móvil")
ax3.set_title("Media móvil", pad=10)


canvas = FigureCanvasTkAgg(fig, master=content_graf)
canvas.draw()
canvas.get_tk_widget().grid(row=0, column=0, sticky="nsew")

# =================== 2) Radar ===================
add_fullscreen_header(frame_radar, "Radar ultrasónico")

radar_inner = Frame(frame_radar, bg=CARD_BG)
radar_inner.grid(row=1, column=0, sticky="nsew", padx=4, pady=4)
radar_inner.grid_rowconfigure(0, weight=1)
radar_inner.grid_columnconfigure(0, weight=1)


def abrir_radar():
    for w in radar_inner.winfo_children():
        w.destroy()

    fig_radar = Figure(figsize=(4, 4), dpi=100)
    ax_r = fig_radar.add_subplot(111, polar=True)

    fig_radar.patch.set_facecolor(CARD_BG)
    ax_r.set_facecolor("black")

    ax_r.set_theta_zero_location('N')
    ax_r.set_theta_direction(1)
    ax_r.set_thetamin(-90)
    ax_r.set_thetamax(90)

    ax_r.set_rlim(0, 400)
    ax_r.set_rticks(range(0, 401, 50))
    ax_r.set_yticklabels([str(r) for r in range(0, 401, 50)],
                         color="#00ff80", fontsize=8)

    ang_ticks = np.deg2rad(np.arange(-90, 91, 30))
    ax_r.set_xticks(ang_ticks)
    ax_r.set_xticklabels([f"{deg}°" for deg in range(-90, 91, 30)],
                         color="#00ff80", fontsize=8)

    ax_r.grid(color="#008000", alpha=0.4)
    ax_r.spines['polar'].set_color("#00ff80")
    ax_r.tick_params(colors="#00ff80")

    ax_r.set_title("Radar ultrasónico", color='lime')

    info_text = ax_r.text(0.5, 1.05, "", transform=ax_r.transAxes,
                          ha="center", va="bottom", color="white", fontsize=10)

    canvas_r = FigureCanvasTkAgg(fig_radar, master=radar_inner)
    canvas_r.draw()
    canvas_r.get_tk_widget().grid(row=0, column=0, sticky="nsew")

    beam_line, = ax_r.plot([], [], color="#00ff80", linewidth=2)

    trail_length = 30
    trail_lines = []
    for i_local in range(trail_length):
        alpha = max(0, 0.4 - i_local * 0.012)
        line, = ax_r.plot([], [], color="#00ff80", linewidth=1.2, alpha=alpha)
        trail_lines.append(line)

    echo_scatter = ax_r.scatter([], [], s=40, c="#00ff00")

    frame_counter = {"n": 0}

    def actualizar_radar_local():
        frame_counter["n"] += 1

        angle_deg = -90 + (frame_counter["n"] * 2.0) % 180
        angle = math.radians(angle_deg)

        r = np.linspace(0, 400, 200)
        theta = np.full_like(r, angle)
        beam_line.set_data(theta, r)

        prev_theta, prev_r = beam_line.get_data()
        last_theta, last_r = prev_theta, prev_r
        for line in trail_lines:
            lt, lr = line.get_data()
            line.set_data(last_theta, last_r)
            last_theta, last_r = lt, lr

        if radar_echoes:
            vivos = []
            for eco in radar_echoes:
                eco["age"] += 1
                if eco["age"] <= RADAR_MAX_AGE:
                    vivos.append(eco)
            radar_echoes[:] = vivos

            if radar_echoes:
                t = [math.radians(e["ang"] - 90.0) for e in radar_echoes]
                d = [e["dist"] for e in radar_echoes]
                alphas = [max(0.0, 1.0 - e["age"] / RADAR_MAX_AGE) for e in radar_echoes]
                colors = [[0.0, 1.0, 0.0, a] for a in alphas]
                offsets = np.column_stack([t, d])
                echo_scatter.set_offsets(offsets)
                echo_scatter.set_color(colors)

                ang_last = radar_echoes[-1]["ang"]
                dist_last = radar_echoes[-1]["dist"]
                info_text.set_text(f"Ángulo: {ang_last:.1f}° Distancia: {dist_last:.1f} cm")
            else:
                echo_scatter.set_offsets(np.empty((0, 2)))
                echo_scatter.set_color([])
                info_text.set_text("Sin ecos")
        else:
            echo_scatter.set_offsets(np.empty((0, 2)))
            echo_scatter.set_color([])
            info_text.set_text("Sin ecos")

        canvas_r.draw()
        window.after(60, actualizar_radar_local)

    actualizar_radar_local()


abrir_radar()

# =================== 3) Órbita: 3D + mapa ===================

add_fullscreen_header(frame_orbita, "Órbita / Mapa mundi")

orbita_inner = Frame(frame_orbita, bg=CARD_BG)
orbita_inner.grid(row=1, column=0, sticky="nsew", padx=4, pady=4)
orbita_inner.grid_rowconfigure(0, weight=1)
orbita_inner.grid_columnconfigure(0, weight=1)

orbit_mode = StringVar(value="3d")

frame_orbit3d = Frame(orbita_inner, bg=CARD_BG)
frame_orbitmap = Frame(orbita_inner, bg=CARD_BG)
for fr in (frame_orbit3d, frame_orbitmap):
    fr.grid(row=0, column=0, sticky="nsew")


def show_orbit_mode():
    if orbit_mode.get() == "3d":
        frame_orbit3d.lift()
    else:
        frame_orbitmap.lift()


def toggle_orbit_mode():
    orbit_mode.set("map" if orbit_mode.get() == "3d" else "3d")
    show_orbit_mode()


btn_toggle = Button(frame_orbita, text="Modo: 3D / Mapa",
                    bg="#333333", fg=TEXT_FG, bd=0,
                    command=toggle_orbit_mode)
btn_toggle.grid(row=0, column=1, sticky="e", padx=40, pady=4)

# --- ÓRBITA 3D ---
def crear_orbita_3d():
    fig_local = Figure(figsize=(10, 10), dpi=100)
    ax_local = fig_local.add_subplot(111, projection='3d')

    fig_local.patch.set_facecolor(CARD_BG)
    ax_local.set_facecolor("#000000")
    ax_local.set_title("Órbita Satélite 3D", color=TEXT_FG)
    ax_local.set_xlabel("X (m)", color=TEXT_FG)
    ax_local.set_ylabel("Y (m)", color=TEXT_FG)
    ax_local.set_zlabel("Z (m)", color=TEXT_FG)
    ax_local.tick_params(colors=TEXT_FG)

    R_EARTH_3D = R_EARTH
    u = np.linspace(0, 2 * np.pi, 40)
    v = np.linspace(0, np.pi, 20)
    x_sphere = R_EARTH_3D * np.outer(np.cos(u), np.sin(v))
    y_sphere = R_EARTH_3D * np.outer(np.sin(u), np.sin(v))
    z_sphere = R_EARTH_3D * np.outer(np.ones_like(u), np.cos(v))
    ax_local.plot_surface(x_sphere, y_sphere, z_sphere, color='#1e90ff',
                          edgecolor='none', alpha=0.9)

    orbit_line, = ax_local.plot([], [], [], '-', linewidth=2, color='yellow', label='Órbita')
    satellite_marker, = ax_local.plot([], [], [], 'o', markersize=6, color='red', label='Satélite')
    ax_local.legend(facecolor="#111111", edgecolor="#444444", labelcolor=TEXT_FG)

    canvas_local = FigureCanvasTkAgg(fig_local, master=frame_orbit3d)
    canvas_local.draw()
    canvas_local.get_tk_widget().grid(row=0, column=0, sticky="nsew")
    canvas_widget = canvas_local.get_tk_widget()
    canvas_widget.place(relx=0.5, rely=0.5, anchor="center")


    last_len = {"n": 0}

    def actualizar_local():
        if len(x_orbit) != last_len["n"] and x_orbit and y_orbit and z_orbit:
            last_len["n"] = len(x_orbit)

            xo = np.array(x_orbit)
            yo = np.array(y_orbit)
            zo = np.array(z_orbit)

            orbit_line.set_data(xo, yo)
            orbit_line.set_3d_properties(zo)

            satellite_marker.set_data(xo[-1:], yo[-1:])
            satellite_marker.set_3d_properties(zo[-1:])

            margin = 0.1
            x_min, x_max = xo.min(), xo.max()
            y_min, y_max = yo.min(), yo.max()
            z_min, z_max = zo.min(), zo.max()

            dx = x_max - x_min
            dy = y_max - y_min
            dz = z_max - z_min
            max_range = max(dx, dy, dz) * (1 + margin)
            if max_range == 0:
                max_range = R_EARTH_3D * 0.5

            cx = (x_max + x_min) / 2.0
            cy = (y_max + y_min) / 2.0
            cz = (z_max + z_min) / 2.0

            ax_local.set_xlim(cx - max_range / 2, cx + max_range / 2)
            ax_local.set_ylim(cy - max_range / 2, cy + max_range / 2)
            ax_local.set_zlim(cz - max_range / 2, cz + max_range / 2)
            ax_local.set_box_aspect([1, 1, 1])

            canvas_local.draw()

        window.after(800, actualizar_local)

    actualizar_local()


# --- MAPA MUNDI + SATÉLITE, USANDO DATOS REALES, PERO FORZANDO SENO ---
def crear_orbita_mapa():
    fig_map = Figure(figsize=(15, 15), dpi=100)
    ax_map = fig_map.add_subplot(111)

    fig_map.patch.set_facecolor(CARD_BG)
    ax_map.set_facecolor("#000000")
    ax_map.set_title("Ground track (real + forma sinusoidal)", color=TEXT_FG)
    ax_map.tick_params(colors=TEXT_FG)
    for spine in ax_map.spines.values():
        spine.set_color(TEXT_FG)

    try:
        img = plt.imread(MAP_IMAGE_PATH)
    except Exception as e:
        registrar_evento("ERRORES", f"No se pudo cargar mapa: {e}")
        img = np.zeros((480, 960, 3), dtype=np.uint8)

    ax_map.imshow(img, extent=[-180, 180, -90, 90], origin='upper')

    track_line, = ax_map.plot([], [], '-', color='yellow', linewidth=1.5, label="Trayectoria")
    sat_point, = ax_map.plot([], [], 'ro', markersize=6, label="Satélite")

    ax_map.set_xlim(-180, 180)
    ax_map.set_ylim(-90, 90)
    ax_map.legend(facecolor="#111111", edgecolor="#444444", labelcolor=TEXT_FG)

    canvas_map = FigureCanvasTkAgg(fig_map, master=frame_orbitmap)
    canvas_map.draw()
    canvas_widget = canvas_map.get_tk_widget()  # ✅ Cambia canvas_local por canvas_map
    canvas_widget.grid(row=0, column=0, sticky="nsew")
    canvas_widget.place(relx=0.5, rely=0.5, anchor="center")  # ✅ Ahora SÍ funciona



    def xyz_to_latlon_simple(x, y, z):
        r = math.sqrt(x * x + y * y + z * z)
        if r == 0:
            return 0.0, 0.0
        lat = math.degrees(math.asin(z / r))
        lon = math.degrees(math.atan2(y, x))
        lon = (lon + 180.0) % 360.0 - 180.0
        return lat, lon

    k = 2.0 * math.pi / 180.0
    phase = 0.0
    last_len = {"n": 0}

    def actualizar_mapa():
        if len(x_orbit) != last_len["n"] and x_orbit and y_orbit and z_orbit:
            last_len["n"] = len(x_orbit)

            lats_real = []
            lons_real = []
            for X, Y, Z in zip(x_orbit, y_orbit, z_orbit):
                lat_r, lon_r = xyz_to_latlon_simple(X, Y, Z)
                lats_real.append(lat_r)
                lons_real.append(lon_r)

            if lats_real:
                N = min(500, len(lats_real))
                lat_slice = lats_real[-N:]
                amp = max(60.0, min(89.0, max(abs(v) for v in lat_slice)))
            else:
                amp = 75.0

            # Forzar latitud sinusoidal
            lats_forzadas = [amp * math.sin(k * lon_r + phase)
                             for lon_r in lons_real]

            # --- NUEVO: romper la línea cuando hay salto grande de longitud ---
            lons_plot = [lons_real[0]]
            lats_plot = [lats_forzadas[0]]
            for idx in range(1, len(lons_real)):
                lon_prev = lons_real[idx - 1]
                lon_cur = lons_real[idx]
                lat_cur = lats_forzadas[idx]
                if abs(lon_cur - lon_prev) > 180:  # salto tipo 170 -> -170
                    lons_plot.append(float('nan'))
                    lats_plot.append(float('nan'))
                lons_plot.append(lon_cur)
                lats_plot.append(lat_cur)
            # Matplotlib no dibuja líneas a través de puntos NaN. [web:432][web:441]

            track_line.set_data(lons_plot, lats_plot)

            lon_last = lons_real[-1]
            lat_last = lats_forzadas[-1]
            sat_point.set_data([lon_last], [lat_last])

            canvas_map.draw()

        window.after(800, actualizar_mapa)

    actualizar_mapa()


crear_orbita_3d()
crear_orbita_mapa()
show_orbit_mode()

# =================== 4) Controles (igual que antes) ===================

add_fullscreen_header(frame_controles, "Controles y parámetros")

cont_inner = Frame(frame_controles, bg="black")
cont_inner.grid(row=1, column=0, sticky="nsew", padx=8, pady=8)

for r in range(20):
    cont_inner.grid_rowconfigure(r, weight=0)
cont_inner.grid_rowconfigure(19, weight=1)
for c in range(3):
    cont_inner.grid_columnconfigure(c, weight=1)

BTN_BG = "#3b4252"
BTN_FG = "#eceff4"
LABEL_FONT = ("Segoe UI", 11)
ENTRY_FONT = ("Segoe UI", 11)

Label(cont_inner, text="Ground Station v2.7",
      bg="black", fg=TEXT_FG, font=("Segoe UI", 14, "bold")).grid(
    row=0, column=0, columnspan=3, sticky="w", pady=(0, 8)
)

Label(cont_inner, text="Límite temperatura (°C):",
      bg="black", fg=TEXT_FG, font=LABEL_FONT).grid(
    row=1, column=0, sticky="w", pady=2
)
limiteVar = StringVar(value=str(limite_temp))
Entry(cont_inner, textvariable=limiteVar, width=8,
      bg="#2b2b2b", fg=TEXT_FG, insertbackground=TEXT_FG,
      relief="flat", font=ENTRY_FONT).grid(
    row=1, column=1, sticky="w", padx=(4, 4), pady=2
)

Label(cont_inner, text="Ventana media móvil (N):",
      bg="black", fg=TEXT_FG, font=LABEL_FONT).grid(
    row=2, column=0, sticky="w", pady=2
)
ventanaVar = IntVar(value=ventana_default)
Spinbox(cont_inner, from_=1, to=200, textvariable=ventanaVar, width=6,
        bg="#2b2b2b", fg=TEXT_FG, buttonbackground="#444444",
        relief="flat", font=ENTRY_FONT).grid(
    row=2, column=1, sticky="w", padx=(4, 4), pady=2
)
ventanaVar.trace_add("write", lambda *args: recalcular_media())

Label(cont_inner, text="Intervalo envío DHT (s):",
      bg="black", fg=TEXT_FG, font=LABEL_FONT).grid(
    row=3, column=0, sticky="w", pady=2
)
intervaloDHTVar = IntVar(value=3)
Spinbox(cont_inner, from_=1, to=3600, textvariable=intervaloDHTVar, width=6,
        bg="#2b2b2b", fg=TEXT_FG, buttonbackground="#444444",
        relief="flat", font=ENTRY_FONT).grid(
    row=3, column=1, sticky="w", padx=(4, 4), pady=2
)

Label(cont_inner, text="Intervalo ultrasonidos (ms):",
      bg="black", fg=TEXT_FG, font=LABEL_FONT).grid(
    row=4, column=0, sticky="w", pady=2
)
intervaloUltraVar = IntVar(value=300)
Spinbox(cont_inner, from_=50, to=10000, textvariable=intervaloUltraVar, width=8,
        bg="#2b2b2b", fg=TEXT_FG, buttonbackground="#444444",
        relief="flat", font=ENTRY_FONT).grid(
    row=4, column=1, sticky="w", padx=(4, 4), pady=2
)


def send_intervalo_dht():
    try:
        s = int(intervaloDHTVar.get())
        mySerial.write(f"1:{s}\n".encode())
    except:
        messagebox.showerror("Error", "Intervalo DHT inválido")
    registrar_evento("COMANDOS", f"Enviar intervalo DHT: {intervaloDHTVar.get()}s")


def send_intervalo_ultra():
    try:
        ms = int(intervaloUltraVar.get())
        mySerial.write(f"7:{ms}\n".encode())
    except:
        messagebox.showerror("Error", "Intervalo ultrasonidos inválido")
    registrar_evento("COMANDOS", f"Enviar intervalo ultrasonidos: {intervaloUltraVar.get()}ms")


Label(cont_inner, text="Dónde calcular la media:",
      bg="black", fg=TEXT_FG, font=LABEL_FONT).grid(
    row=5, column=0, sticky="w", pady=(8, 2)
)
modoVar = StringVar(value="python")


def modo_media_changed():
    global modo_media
    modo_media = modoVar.get()
    if modo_media == "arduino":
        try:
            mySerial.write(b"8:1\n")
            time.sleep(0.05)
            n = int(ventanaVar.get())
            mySerial.write(f"9:{n}\n".encode())
        except:
            pass
    else:
        try:
            mySerial.write(b"8:0\n")
        except:
            pass


Radiobutton(cont_inner, text="Python (local)", variable=modoVar, value="python",
            command=modo_media_changed, bg="black", fg=TEXT_FG,
            selectcolor="#333333", font=LABEL_FONT).grid(
    row=5, column=1, sticky="w", pady=(8, 2)
)
Radiobutton(cont_inner, text="Arduino (remoto)", variable=modoVar, value="arduino",
            command=modo_media_changed, bg="black", fg=TEXT_FG,
            selectcolor="#333333", font=LABEL_FONT).grid(
    row=5, column=2, sticky="w", pady=(8, 2)
)

Label(cont_inner, text="Ángulo servo (0-180°):",
      bg="black", fg=TEXT_FG, font=LABEL_FONT).grid(
    row=6, column=0, sticky="w", pady=2
)
anguloVar = IntVar(value=0)
Entry(cont_inner, textvariable=anguloVar, width=6,
      bg="#2b2b2b", fg=TEXT_FG, insertbackground=TEXT_FG,
      relief="flat", font=ENTRY_FONT).grid(
    row=6, column=1, sticky="w", padx=(4, 4), pady=2
)


def enviar_angulo():
    try:
        ang = int(anguloVar.get())
        if 0 <= ang <= 180:
            mySerial.write(f"2:{ang}\n".encode())
            registrar_evento("COMANDOS", f"Enviar ángulo servo: {ang}°")
        else:
            messagebox.showerror("Error", "Ángulo debe estar entre 0 y 180")
    except:
        messagebox.showerror("Error", "Ángulo inválido")


Label(cont_inner, text="Estado alarma (medias):",
      bg="black", fg=TEXT_FG, font=LABEL_FONT).grid(
    row=7, column=0, sticky="w", pady=(8, 2)
)
alarma_media_label = Label(cont_inner, text="NORMAL", bg="lightgreen",
                           fg='black', width=18, font=("Segoe UI", 11, "bold"))
alarma_media_label.grid(row=7, column=1, sticky="w", padx=(4, 4), pady=(8, 2))

Label(cont_inner, text="Registrar observación:",
      bg="black", fg=TEXT_FG, font=LABEL_FONT).grid(
    row=8, column=0, sticky="w", pady=(8, 2)
)
observacionVar = StringVar()
Entry(cont_inner, textvariable=observacionVar,
      bg="#2b2b2b", fg=TEXT_FG, insertbackground=TEXT_FG,
      relief="flat", font=ENTRY_FONT).grid(
    row=8, column=1, columnspan=2, sticky="ew", padx=(4, 4), pady=(8, 2)
)


def registrar_observacion():
    obs = observacionVar.get().strip()
    if obs:
        registrar_evento("OBSERVACION", obs)
        messagebox.showinfo("Observación registrada", "Se ha guardado la observación en el log.")
        observacionVar.set("")
    else:
        messagebox.showwarning("Campo vacío", "Ingrese una observación antes de registrar.")


def abrir_visor_eventos():
    try:
        with open(LOG_FILE, "r", encoding="utf-8") as f:
            lineas = f.readlines()
    except FileNotFoundError:
        messagebox.showwarning("Aviso", "No hay log de eventos todavía.")
        return

    visor = Toplevel(window)
    visor.title("Visor de Eventos")
    visor.geometry("800x600")

    filtro_frame = Frame(visor)
    filtro_frame.pack(side=TOP, fill=X, padx=5, pady=5)

    Label(filtro_frame, text="Filtrar por tipo:").pack(side=LEFT)
    tipo_var = StringVar(value="TODOS")
    tipos_eventos = ["TODOS", "ERRORES", "COMANDOS", "INFO SATELITE"]
    tipo_menu = OptionMenu(filtro_frame, tipo_var, *tipos_eventos)
    tipo_menu.pack(side=LEFT, padx=(5, 15))

    Label(filtro_frame, text="Buscar texto:").pack(side=LEFT)
    texto_buscar_var = StringVar()
    Entry(filtro_frame, textvariable=texto_buscar_var, width=20).pack(side=LEFT, padx=(5, 15))

    text_frame = Frame(visor)
    text_frame.pack(fill=BOTH, expand=True, padx=5, pady=5)
    scrollbar = Scrollbar(text_frame)
    scrollbar.pack(side=RIGHT, fill=Y)
    text_area = Text(text_frame, wrap=NONE, yscrollcommand=scrollbar.set)
    text_area.pack(fill=BOTH, expand=True)
    scrollbar.config(command=text_area.yview)

    def actualizar_texto():
        text_area.delete(1.0, END)
        tipo_filtro = tipo_var.get()
        buscar_texto = texto_buscar_var.get().strip().lower()
        for linea in lineas:
            mostrar = False
            if tipo_filtro == "TODOS":
                mostrar = True
            elif tipo_filtro == "ERRORES" and ("fallo" in linea.lower() or "error" in linea.lower()):
                mostrar = True
            elif tipo_filtro == "COMANDOS" and "COMANDOS" in linea:
                mostrar = True
            elif tipo_filtro == "INFO SATELITE" and ("satélite msg:" in linea.lower() or "otro mensaje:" in linea.lower()):
                mostrar = True
            if buscar_texto and buscar_texto not in linea.lower():
                mostrar = False
            if mostrar:
                text_area.insert(END, linea)
                text_area.see(END)

    Button(filtro_frame, text="Actualizar", command=actualizar_texto).pack(side=RIGHT)
    actualizar_texto()


BTN_FONT = ("Segoe UI", 11, "bold")
BTN_WIDTH = 18
BTN_PADY = 8

row_btn = 10


def IniciarClick():
    global lectura_activa
    lectura_activa = True
    try:
        mySerial.write(b'Iniciar\n')
    except:
        pass
    ciclo_lectura()


def PararClick():
    global lectura_activa
    lectura_activa = False
    try:
        mySerial.write(b'Parar\n')
    except:
        pass


def ReanudarClick():
    global lectura_activa
    lectura_activa = True
    try:
        mySerial.write(b'Iniciar\n')
    except:
        pass
    ciclo_lectura()


def ResetClick():
    global temperaturas, humedades, eje_x, media_movil, i
    global radar_echoes, alerta_activa, alerta_media_activa
    global x_orbit, y_orbit, z_orbit
    temperaturas = []
    humedades = []
    eje_x = []
    media_movil = []
    i = 0
    radar_echoes = []
    x_orbit = []
    y_orbit = []
    z_orbit = []
    alerta_activa = False
    alerta_media_activa = False
    alarma_media_label.config(text="Normal", bg="lightgreen")
    try:
        mySerial.write(b'6:1\n')
    except:
        pass
    actualizar_graficas(force=True)


Button(cont_inner, text="Iniciar", bg="#19BB0A", fg='white',
       command=IniciarClick, width=BTN_WIDTH, font=BTN_FONT).grid(
    row=row_btn, column=0, columnspan=3, pady=BTN_PADY
)
row_btn += 1
Button(cont_inner, text="Parar", bg="#E50606", fg='white',
       command=PararClick, width=BTN_WIDTH, font=BTN_FONT).grid(
    row=row_btn, column=0, columnspan=3, pady=BTN_PADY
)
row_btn += 1
Button(cont_inner, text="Reanudar", bg="#EA7A12", fg='white',
       command=ReanudarClick, width=BTN_WIDTH, font=BTN_FONT).grid(
    row=row_btn, column=0, columnspan=3, pady=BTN_PADY
)
row_btn += 1
Button(cont_inner, text="Reset (reactiva barrido)", bg="#EFE410", fg='black',
       command=ResetClick, width=BTN_WIDTH, font=BTN_FONT).grid(
    row=row_btn, column=0, columnspan=3, pady=BTN_PADY
)
row_btn += 1
Button(cont_inner, text="Enviar intervalos",
       command=lambda: (send_intervalo_dht(), send_intervalo_ultra()),
       bg=BTN_BG, fg=BTN_FG, relief="flat",
       font=BTN_FONT, width=BTN_WIDTH).grid(
    row=row_btn, column=0, columnspan=3, pady=BTN_PADY
)
row_btn += 1
Button(cont_inner, text="Enviar ángulo servo", command=enviar_angulo,
       bg=BTN_BG, fg=BTN_FG, relief="flat",
       font=BTN_FONT, width=BTN_WIDTH).grid(
    row=row_btn, column=0, columnspan=3, pady=BTN_PADY
)
row_btn += 1
Button(cont_inner, text="Registrar observación", command=registrar_observacion,
       bg=BTN_BG, fg=BTN_FG, relief="flat",
       font=BTN_FONT, width=BTN_WIDTH).grid(
    row=row_btn, column=0, columnspan=3, pady=BTN_PADY
)
row_btn += 1
Button(cont_inner, text="Abrir Visor de Eventos", command=abrir_visor_eventos,
       bg="#C4243F", fg='white', relief="flat",
       font=BTN_FONT, width=BTN_WIDTH).grid(
    row=row_btn, column=0, columnspan=3, pady=BTN_PADY
)


def actualizar_graficas(force=False):
    line_temp.set_data(eje_x, temperaturas)
    line_hum.set_data(eje_x, humedades)

    media_plot = []
    for m in media_movil:
        if m is None or (isinstance(m, float) and math.isnan(m)):
            media_plot.append(0)
        else:
            media_plot.append(m)

    line_avg.set_data(eje_x[:len(media_plot)], media_plot)

    ax1.relim()
    ax1.autoscale_view()
    ax2.relim()
    ax2.autoscale_view()
    ax3.relim()
    ax3.autoscale_view()

    canvas.draw()


def leer_serial():
    global i, alerta_activa, alerta_media_activa, last_angle_received, last_dht_accepted_ms

    try:
        while mySerial.in_waiting > 0:
            raw = mySerial.readline().decode('utf-8', errors='ignore').strip()
            if not raw:
                continue

            if raw.startswith("CHK:"):
                try:
                    partes = raw.split(':')
                    if len(partes) < 3:
                        registrar_evento("ERRORES", "Mensaje corrupto (checksum incompleto)")
                        continue
                    data = ':'.join(partes[1:-1])
                    checksum_recv = int(partes[-1])
                    checksum_calc = sum(bytearray(data, 'utf-8')) % 256
                    if checksum_recv != checksum_calc:
                        registrar_evento("ERRORES", f"Checksum inválido: {raw}")
                        continue
                    raw = data
                except Exception as e:
                    registrar_evento("ERRORES", f"Error leyendo checksum: {raw} ({e})")
                    continue

            trozos = raw.split(':')
            now_ms = int(time.time() * 1000)

            if len(trozos) >= 3 and trozos[0] == '1':
                intervalo_ms = max(0, int(intervaloDHTVar.get())) * 1000
                if intervalo_ms == 0 or now_ms - last_dht_accepted_ms >= intervalo_ms:
                    last_dht_accepted_ms = now_ms
                    try:
                        temperatura = float(trozos[1])
                        hum = float(trozos[2])
                    except:
                        continue
                    eje_x.append(i)
                    temperaturas.append(temperatura)
                    humedades.append(hum)
                    i += 1

                    N = max(1, int(ventanaVar.get()))
                    if modoVar.get() == "arduino" and len(trozos) >= 5 and trozos[3] == 'A':
                        try:
                            media_movil.append(float(trozos[4]))
                        except:
                            media_movil.append(
                                sum(temperaturas[-N:]) / N if len(temperaturas) >= N else float('nan'))
                    else:
                        media_movil.append(
                            sum(temperaturas[-N:]) / N if len(temperaturas) >= N else float('nan'))

                    if len(temperaturas) >= 3 and all(
                            x > float(limiteVar.get()) for x in temperaturas[-3:]) and not alerta_activa:
                        alerta_activa = True
                        messagebox.showwarning("Alerta", f"Últimas 3 temperaturas superan {limiteVar.get()} °C")
                        registrar_evento("ERRORES",
                                         f"Alerta temperatura: últimas 3 superan {limiteVar.get()} °C")
                    elif alerta_activa and len(temperaturas) >= 3 and not all(
                            x > float(limiteVar.get()) for x in temperaturas[-3:]):
                        alerta_activa = False

                    medias_validas = [m for m in media_movil if not (isinstance(m, float) and math.isnan(m))]
                    if len(medias_validas) >= 3 and all(
                            m > float(limiteVar.get()) for m in medias_validas[-3:]):
                        alerta_media_activa = True
                        alarma_media_label.config(text="Peligro", bg="red")
                    else:
                        alerta_media_activa = False
                        alarma_media_label.config(text="Normal", bg="lightgreen")

            elif len(trozos) >= 3 and trozos[0] == '2':
                try:
                    ang = float(trozos[1])
                    dist = float(trozos[2])
                    last_angle_received = ang

                    if 0 <= ang <= 180:
                        radar_echoes.append({"ang": ang, "dist": dist, "age": 0})
                        if len(radar_echoes) > RADAR_MAX_POINTS:
                            radar_echoes[:] = radar_echoes[-RADAR_MAX_POINTS:]
                    else:
                        registrar_evento("ERRORES", f"Ángulo radar inválido: {ang}")
                except Exception as e:
                    registrar_evento("ERRORES", f"Radar inválido: {raw} ({e})")

            elif trozos[0] == '3':
                registrar_evento("ERRORES", "Satélite: fallo DHT")
            elif trozos[0] == '5':
                registrar_evento("INFO SATELITE", "Satélite msg: " + ":".join(trozos[1:]))
            elif trozos[0] == '6':
                registrar_evento("ERRORES", "Satélite: fallo sensor distancia")
            else:
                registrar_evento("INFO SATELITE", "Otro mensaje: " + raw)

            match = regex_orbit.search(raw)
            if match:
                try:
                    x_orbit.append(float(match.group(1)))
                    y_orbit.append(float(match.group(2)))
                    z_orbit.append(float(match.group(3)))

                    if len(x_orbit) > MAX_ORBIT_POINTS:
                        x_orbit[:] = x_orbit[-MAX_ORBIT_POINTS:]
                        y_orbit[:] = y_orbit[-MAX_ORBIT_POINTS:]
                        z_orbit[:] = z_orbit[-MAX_ORBIT_POINTS:]
                except ValueError:
                    registrar_evento("ERRORES", f"Órbita inválida: {raw}")

    except serial.SerialException as e:
        print("Error puerto serie:", e)
        registrar_evento("ERRORES", f"Error puerto serie: {e}")


def ciclo_lectura():
    if lectura_activa:
        leer_serial()
        actualizar_graficas()
        window.after(120, ciclo_lectura)


def on_close():
    global lectura_activa
    lectura_activa = False
    try:
        mySerial.close()
    except:
        pass
    window.destroy()


window.protocol("WM_DELETE_WINDOW", on_close)
window.mainloop()

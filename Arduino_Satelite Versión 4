// =====================================================
// üõ∞Ô∏è SAT√âLITE v4.8 - DHT + Ultrasonidos + Servo + √ìrbita + AMENAZA ‚Üí TIERRA
// =====================================================

#include <SoftwareSerial.h>
#include <DHT.h>
#include <Servo.h>

// ------------------ PINES ------------------
#define DHTPIN 2
#define DHTTYPE DHT11
#define TRIGPIN 6
#define ECHOPIN 7
#define SERVOPIN 9
#define MOTORPIN 12
#define LEDRX 13

// ------------------ OBJETOS ------------------
SoftwareSerial mySerial(10, 11); // RX, TX hacia estaci√≥n (puente)
DHT dht(DHTPIN, DHTTYPE);
Servo servoMotor;

// ------------------ ESTADO GLOBAL ------------------
bool transmitiendo      = false;
bool modoBarrido        = false;   // barrido autom√°tico del servo
bool arduinoComputeAvg  = false;
bool amenazaActiva      = false;   // para AMENAZA_ON/OFF

// ------------------ TIEMPOS ------------------
unsigned long intervaloHT    = 5000;
unsigned long nextHT         = 0;
unsigned long intervaloServo = 300;
unsigned long nextServo      = 0;
unsigned long intervaloUltra = 300;
unsigned long nextUltra      = 0;
unsigned long intervaloOrbit = 3000;
unsigned long nextOrbit      = 0;

// ------------------ SERVO ------------------
int angulo     = 90;
int direccion  = 1;
const int PASO = 15;

// ------------------ MEDIA TEMPERATURA ------------------
#define MAX_WINDOW 100
float tempBuffer[MAX_WINDOW];
int   tempCount = 0;
int   windowN   = 10;

// ------------------ √ìRBITA ------------------
const double G                = 6.67430e-11;
const double M                = 5.97219e24;
const double R_EARTH          = 6371000;
const double ALTITUDE         = 400000;
const double TIME_COMPRESSION = 90.0;
double r, real_orbital_period;

// =====================================================
// CHECKSUM
// =====================================================
unsigned int checksum(String msg) {
  unsigned int sum = 0;
  for (unsigned int i = 0; i < msg.length(); i++) sum += msg[i];
  return sum % 256;
}

void sendMsg(String msg) {
  mySerial.print("CHK:");
  mySerial.print(msg);
  mySerial.print(":");
  mySerial.println(checksum(msg));
}

String limpiarChecksum(String raw) {
  raw.trim();
  if (!raw.startsWith("CHK:")) return raw;
  raw = raw.substring(4);
  int lastColon = raw.lastIndexOf(':');
  if (lastColon > 0) raw = raw.substring(0, lastColon);
  return raw;
}

// =====================================================
// ULTRASONIDOS
// =====================================================
float medirDistancia() {
  digitalWrite(TRIGPIN, LOW); delayMicroseconds(2);
  digitalWrite(TRIGPIN, HIGH); delayMicroseconds(10);
  digitalWrite(TRIGPIN, LOW);
  long duracion = pulseIn(ECHOPIN, HIGH, 25000);
  if (duracion == 0) return -1;
  return duracion * 0.034 / 2.0;
}

// =====================================================
// MEDIA TEMPERATURA
// =====================================================
void pushTemp(float t) {
  if (tempCount < MAX_WINDOW) tempBuffer[tempCount++] = t;
  else {
    for (int i = 0; i < MAX_WINDOW - 1; i++)
      tempBuffer[i] = tempBuffer[i + 1];
    tempBuffer[MAX_WINDOW - 1] = t;
  }
}

float computeAvg() {
  int n = min(tempCount, windowN);
  if (n == 0) return NAN;
  float s = 0;
  for (int i = tempCount - n; i < tempCount; i++) s += tempBuffer[i];
  return s / n;
}

// =====================================================
// √ìRBITA
// =====================================================
void enviarOrbita(unsigned long ms) {
  double time  = (ms / 1000.0) * TIME_COMPRESSION;
  double angle = 2 * PI * (time / real_orbital_period);
  double x = r * cos(angle);
  double y = r * sin(angle);
  double z = 0;
  String msg = "Orbit | Time: " + String(time, 2) +
               " s | X: "  + String(x, 2) +
               " m, Y: "   + String(y, 2) +
               " m, Z: "   + String(z, 2);
  sendMsg(msg);
}

// =====================================================
// COMANDOS DESDE TIERRA
// =====================================================
void procesarComando(String cmd) {
  cmd.trim();
  if (cmd.length() == 0) return;

  // Comandos de texto directos
  if (cmd == "Iniciar") {
    transmitiendo = true;
    modoBarrido   = true;      // al iniciar, barrido ON
    unsigned long now = millis();
    nextHT    = now;
    nextServo = now;
    nextUltra = now;
    nextOrbit = now;
    sendMsg("5:INICIADO");
    return;
  }

  if (cmd == "Parar") {
    transmitiendo = false;
    sendMsg("5:PARADO");
    return;
  }

  // Comandos num√©ricos tipo "1:10", "2:90", "60", "61"...
  int sep  = cmd.indexOf(':');
  int code = (sep < 0) ? cmd.toInt() : cmd.substring(0, sep).toInt();
  String val = (sep < 0) ? "" : cmd.substring(sep + 1);

  // DEBUG opcional
  // Serial.print("CMD='"); Serial.print(cmd);
  // Serial.print("' code="); Serial.print(code);
  // Serial.print(" val='"); Serial.print(val);
  // Serial.println("'");

  switch (code) {

    // 1:segundos ‚Üí intervalo DHT
    case 1: {
      int s = val.toInt();
      if (s >= 1 && s <= 3600) {
        intervaloHT = s * 1000UL;
        nextHT = millis() + intervaloHT;
        sendMsg("5:PERIODO_DHT=" + String(s));
      }
      break;
    }

    // 2:angulo ‚Üí servo manual
    case 2: {
      angulo = constrain(val.toInt(), 0, 180);
      modoBarrido = false;              // pasa a modo manual
      servoMotor.write(angulo);
      sendMsg("5:SERVO_MANUAL=" + String(angulo));
      break;
    }

    // 6:ms ‚Üí intervalo ultrasonidos (si quieres este formato)
    case 6: {
      unsigned long ms = val.toInt();
      if (ms < 50) ms = 50;
      intervaloUltra = ms;
      nextUltra = millis() + intervaloUltra;
      sendMsg("5:ULTRA_MS=" + String(ms));
      break;
    }

    // 60 ‚Üí detener SOLO el barrido del servo
    case 60: {
      modoBarrido = false;
      servoMotor.write(angulo);       // mantiene √°ngulo actual
      sendMsg("5:BARRIDO_OFF");
      break;
    }

    // 61 ‚Üí reanudar barrido del servo
    case 61: {
      modoBarrido = true;
      unsigned long now = millis();
      nextServo = now;
      nextUltra = now;               // opcional: para que dispare ya
      sendMsg("5:BARRIDO_ON");
      break;
    }

    // 8:0 / 8:1 ‚Üí media en Arduino ON/OFF
    case 8: {
      arduinoComputeAvg = (val == "1");
      sendMsg(arduinoComputeAvg ? "5:AVG_ON" : "5:AVG_OFF");
      break;
    }

    // 9:N ‚Üí tama√±o ventana media en Arduino
    case 9: {
      windowN = constrain(val.toInt(), 1, MAX_WINDOW);
      sendMsg("5:WINDOW=" + String(windowN));
      break;
    }

    default:
      sendMsg("5:CMD_DESCONOCIDO");
  }
}

// =====================================================
// SETUP
// =====================================================
void setup() {
  pinMode(TRIGPIN, OUTPUT);
  pinMode(ECHOPIN, INPUT);
  pinMode(MOTORPIN, OUTPUT);
  pinMode(LEDRX, OUTPUT);

  servoMotor.attach(SERVOPIN);
  servoMotor.write(angulo);

  dht.begin();
  Serial.begin(9600);
  mySerial.begin(9600);

  r = R_EARTH + ALTITUDE;
  real_orbital_period = 2 * PI * sqrt(pow(r, 3) / (G * M));

  sendMsg("5:SATELITE_LISTO");
}

// =====================================================
// LOOP
// =====================================================
void loop() {
  // ----- COMANDOS DESDE TIERRA -----
  while (mySerial.available()) {
    String raw    = mySerial.readStringUntil('\n');
    String limpio = limpiarChecksum(raw);
    procesarComando(limpio);
  }

  // Si no transmite, solo mantiene √°ngulo servo actual
  if (!transmitiendo) {
    servoMotor.write(angulo);
    return;
  }

  unsigned long ahora = millis();

  // ----- DHT -----
  if (ahora >= nextHT) {
    nextHT = ahora + intervaloHT;
    delay(500);  // estabilizaci√≥n DHT
    float t = dht.readTemperature();
    float h = dht.readHumidity();
    if (!isnan(t) && !isnan(h)) pushTemp(t);
    String msg = "1:" + String(t, 2) + ":" + String(h, 2);
    if (arduinoComputeAvg) msg += ":A:" + String(computeAvg(), 2);
    sendMsg(msg);
  }

  // ----- SERVO (barrido autom√°tico) -----
  if (modoBarrido && (ahora >= nextServo)) {
    nextServo = ahora + intervaloServo;
    angulo += PASO * direccion;
    if (angulo >= 180 || angulo <= 0) direccion *= -1;
    servoMotor.write(angulo);
  } else {
    // en modo manual ya se fij√≥ angulo desde case 2
    servoMotor.write(angulo);
  }

  // ----- ULTRASONIDOS -----
  if (ahora >= nextUltra) {
    nextUltra = ahora + intervaloUltra;

    float d = medirDistancia();
    if (d < 0) {
      sendMsg("6:");   // fallo sensor
    } else {
      String s = "2:" + String(angulo) + ":" + String(d, 2);
      sendMsg(s);

      // AMENAZA
      if (d > 0 && d <= 50.0) {
        if (!amenazaActiva) {
          amenazaActiva = true;
          sendMsg("5:AMENAZA_ON");
        }
      } else if (d > 50.0) {
        if (amenazaActiva) {
          amenazaActiva = false;
          sendMsg("5:AMENAZA_OFF");
        }
      }
    }
  }

  // ----- √ìRBITA -----
  if (ahora >= nextOrbit) {
    nextOrbit = ahora + intervaloOrbit;
    enviarOrbita(ahora);
  }
}

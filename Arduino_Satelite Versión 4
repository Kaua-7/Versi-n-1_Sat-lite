// =====================================================
// üõ∞Ô∏è SAT√âLITE v4.8 - DHT + Ultrasonidos + Servo + √ìrbita + AMENAZA ‚Üí TIERRA
// =====================================================

#include <SoftwareSerial.h>
#include <DHT.h>
#include <Servo.h>

// ------------------ PINES ------------------
#define DHTPIN 2
#define DHTTYPE DHT11
#define TRIGPIN 6
#define ECHOPIN 7
#define SERVOPIN 9
#define MOTORPIN 12
#define LEDRX 13

// ------------------ OBJETOS ------------------
SoftwareSerial mySerial(10, 11); // RX, TX hacia estaci√≥n (puente)
DHT dht(DHTPIN, DHTTYPE);
Servo servoMotor;

// ------------------ ESTADO GLOBAL ------------------
bool transmitiendo      = false;
bool modoBarrido        = false;
bool arduinoComputeAvg  = false;
bool amenazaActiva      = false;  // Estado para enviar solo cambios

// ------------------ TIEMPOS ------------------
unsigned long intervaloHT    = 5000;
unsigned long nextHT         = 0;
unsigned long intervaloServo = 300;
unsigned long nextServo      = 0;
unsigned long intervaloUltra = 300;   // intervalo ultrasonidos (ms)
unsigned long nextUltra      = 0;
unsigned long intervaloOrbit = 3000;
unsigned long nextOrbit      = 0;

// ------------------ SERVO ------------------
int angulo     = 90;
int direccion  = 1;
const int PASO = 15;

// ------------------ MEDIA TEMPERATURA ------------------
#define MAX_WINDOW 100
float tempBuffer[MAX_WINDOW];
int   tempCount = 0;
int   windowN   = 10;

// ------------------ √ìRBITA ------------------
const double G                = 6.67430e-11;
const double M                = 5.97219e24;
const double R_EARTH          = 6371000;
const double ALTITUDE         = 400000;
const double TIME_COMPRESSION = 90.0;
double r, real_orbital_period;

// =====================================================
// CHECKSUM
unsigned int checksum(String msg) {
  unsigned int sum = 0;
  for (unsigned int i = 0; i < msg.length(); i++) sum += msg[i];
  return sum % 256;
}

void sendMsg(String msg) {
  mySerial.print("CHK:");
  mySerial.print(msg);
  mySerial.print(":");
  mySerial.println(checksum(msg));
}

String limpiarChecksum(String raw) {
  raw.trim();
  if (!raw.startsWith("CHK:")) return raw;
  raw = raw.substring(4);
  int lastColon = raw.lastIndexOf(':');
  if (lastColon > 0) raw = raw.substring(0, lastColon);
  return raw;
}

float medirDistancia() {
  digitalWrite(TRIGPIN, LOW); delayMicroseconds(2);
  digitalWrite(TRIGPIN, HIGH); delayMicroseconds(10);
  digitalWrite(TRIGPIN, LOW);
  long duracion = pulseIn(ECHOPIN, HIGH, 25000);
  if (duracion == 0) return -1;             // fallo / desconectado
  return duracion * 0.034 / 2.0;
}

void pushTemp(float t) {
  if (tempCount < MAX_WINDOW) tempBuffer[tempCount++] = t;
  else {
    for (int i = 0; i < MAX_WINDOW - 1; i++)
      tempBuffer[i] = tempBuffer[i + 1];
    tempBuffer[MAX_WINDOW - 1] = t;
  }
}

float computeAvg() {
  int n = min(tempCount, windowN);
  if (n == 0) return NAN;
  float s = 0;
  for (int i = tempCount - n; i < tempCount; i++) s += tempBuffer[i];
  return s / n;
}

void enviarOrbita(unsigned long ms) {
  double time  = (ms / 1000.0) * TIME_COMPRESSION;
  double angle = 2 * PI * (time / real_orbital_period);
  double x = r * cos(angle);
  double y = r * sin(angle);
  double z = 0;
  String msg = "Orbit | Time: " + String(time, 2) +
               " s | X: "  + String(x, 2) +
               " m, Y: "   + String(y, 2) +
               " m, Z: "   + String(z, 2);
  sendMsg(msg);
}

void procesarComando(String cmd) {
  cmd.trim();
  if (cmd.length() == 0) return;

  if (cmd == "Iniciar") {
    transmitiendo = true;
    modoBarrido  = true;
    unsigned long now = millis();
    nextHT    = now;
    nextServo = now;
    nextUltra = now;
    nextOrbit = now;
    sendMsg("5:INICIADO");
    return;
  }
  if (cmd == "Parar") {
    transmitiendo = false;
    sendMsg("5:PARADO");
    return;
  }

  int sep  = cmd.indexOf(':');
  int code = (sep < 0) ? cmd.toInt() : cmd.substring(0, sep).toInt();
  String val = (sep < 0) ? "" : cmd.substring(sep + 1);

  switch (code) {
    case 1: {
      int s = val.toInt();
      if (s >= 1 && s <= 3600) {
        intervaloHT = s * 1000UL;
        nextHT = millis() + intervaloHT;
        sendMsg("5:PERIODO_DHT=" + String(s));
      }
      break;
    }
    case 2: {
      angulo = constrain(val.toInt(), 0, 180);
      modoBarrido = false;          // servo pasa a modo manual, pero el ultra sigue
      servoMotor.write(angulo);
      sendMsg("5:SERVO_MANUAL=" + String(angulo));
      break;
    }
    case 6: {
      modoBarrido = (val == "1");
      sendMsg(modoBarrido ? "5:BARRIDO_ON" : "5:BARRIDO_OFF");
      break;
    }
    case 7: {
      // Intervalo ultrasonidos
      unsigned long ms = val.toInt();
      if (ms < 50) ms = 50;
      intervaloUltra = ms;
      nextUltra = millis() + intervaloUltra;
      sendMsg("5:ULTRA_MS=" + String(ms));
      break;
    }
    case 8: {
      arduinoComputeAvg = (val == "1");
      sendMsg(arduinoComputeAvg ? "5:AVG_ON" : "5:AVG_OFF");
      break;
    }
    case 9: {
      windowN = constrain(val.toInt(), 1, MAX_WINDOW);
      sendMsg("5:WINDOW=" + String(windowN));
      break;
    }
    default:
      sendMsg("5:CMD_DESCONOCIDO");
  }
}

void setup() {
  pinMode(TRIGPIN, OUTPUT);
  pinMode(ECHOPIN, INPUT);
  pinMode(MOTORPIN, OUTPUT);
  pinMode(LEDRX, OUTPUT);

  servoMotor.attach(SERVOPIN);
  servoMotor.write(angulo);

  dht.begin();
  Serial.begin(9600);
  mySerial.begin(9600);

  r = R_EARTH + ALTITUDE;
  real_orbital_period = 2 * PI * sqrt(pow(r, 3) / (G * M));

  sendMsg("5:SATELITE_LISTO");
}

void loop() {
  while (mySerial.available()) {
    String raw    = mySerial.readStringUntil('\n');
    String limpio = limpiarChecksum(raw);
    procesarComando(limpio);
  }

  if (!transmitiendo) {
    // Si no transmite, solo mantiene el servo en su √°ngulo actual
    servoMotor.write(angulo);
    return;
  }

  unsigned long ahora = millis();

  // DHT con detecci√≥n de fallo (desenchufado -> NaN)
  if (ahora >= nextHT) {
    nextHT = ahora + intervaloHT;
    delay(500);  // estabilizaci√≥n DHT
    float t = dht.readTemperature();
    float h = dht.readHumidity();

    if (isnan(t) || isnan(h)) {
      // Lectura inv√°lida: DHT desconectado o fallo ‚Üí alarma "3:"
      sendMsg("3:");
    } else {
      // Lectura correcta
      pushTemp(t);
      String msg = "1:" + String(t, 2) + ":" + String(h, 2);
      if (arduinoComputeAvg) msg += ":A:" + String(computeAvg(), 2);
      sendMsg(msg);
    }
  }

  // SERVO (solo barrido) + ULTRASONIDOS (siempre)
  if (modoBarrido && (ahora >= nextServo)) {
    nextServo = ahora + intervaloServo;
    angulo += PASO * direccion;
    if (angulo >= 180 || angulo <= 0) direccion *= -1;
    servoMotor.write(angulo);
  } else {
    // En modo manual ya se fij√≥ angulo desde el comando case 2
    servoMotor.write(angulo);
  }

  // ULTRASONIDOS independientemente del barrido
  if (ahora >= nextUltra) {
    nextUltra = ahora + intervaloUltra;

    float d = medirDistancia();
    if (d < 0) {
      // Desenchufado / sin eco ‚Üí alarma "6:"
      sendMsg("6:");
    } else {
      String s = "2:" + String(angulo) + ":" + String(d, 2);
      sendMsg(s);

      // L√ìGICA AMENAZA (solo ON/OFF, no es fallo de sensor)
      if (d > 0 && d <= 50.0) {  // ‚â§ 50cm
        if (!amenazaActiva) {
          amenazaActiva = true;
          sendMsg("5:AMENAZA_ON");
        }
      } else if (d > 50.0) {
        if (amenazaActiva) {
          amenazaActiva = false;
          sendMsg("5:AMENAZA_OFF");
        }
      }
    }
  }

  // √ìRBITA
  if (ahora >= nextOrbit) {
    nextOrbit = ahora + intervaloOrbit;
    enviarOrbita(ahora);
  }
}
